{"title":"UE4使用陀螺仪实现第一人称AR射击游戏","uid":"c498b6832af326070e6d7a91fc3088af","slug":"ue4-gyro","date":"2022-05-23T15:36:33.000Z","updated":"2023-08-27T16:19:08.470Z","comments":true,"path":"api/articles/ue4-gyro.json","keywords":null,"cover":"http://static.pa2sw0rd.cn/static/images/image-13.gif","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在我们的印象里，如果想体验AR游戏，那么就得有一定的硬件支持，其实简单来说，一个AR游戏就是利用电脑模拟产生一个三维空间的虚拟世界，通过相应的硬件传感器将人的行为输入到传统的游戏模式中，再将结果通过视觉或其它的方式反馈给我们，那么我们就用UE4引擎来实现一个简单的例子，起初是想使用硬件陀螺仪来实现这么一个例子，但是想了又想，搞硬件还得动手（其实懒得动），数据处理都在底层，先不说效果怎么样，肯定会遇到一些未知的问题，何况现在手机都有陀螺仪，so~~~~通过手机陀螺仪来实现这样一个例子，等摸清UE4了，再搞个其它有意思的东西玩玩。图片</p>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>UE4第一人称射击例子制作</li>\n<li>UE4蓝图调用自写C++类</li>\n<li>安卓陀螺仪的使用</li>\n<li>socket通信</li>\n</ul>\n<h3 id=\"系统分析\"><a href=\"#系统分析\" class=\"headerlink\" title=\"系统分析\"></a>系统分析</h3><p>通过获取手机陀螺仪的数据，将数据发送到游戏引擎中，游戏引擎通过陀螺仪数据做出相应的变换，那么在这个过程中我们要明确数据怎么搞到引擎中，这里使用手机APP采集陀螺仪数据，通过TCP&#x2F;IP发送到引擎中，但是引擎蓝图是不提供TCP接口的，有插件，但是使用别人的插件你还得理解他人的逻辑，还不如自己搞一个呢，所以这里就使用C++与蓝图结合的方式来实现这个东西。</p>\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><p>话不多说，要实现这样一个小项目，基本的场景得要搭建起来，最起码得搞个物体用陀螺仪来实现他的旋转吧。。。这里就不敷衍了，我们简单搭建一个第一人称的模板，通过陀螺仪实现视角的移动。（这里说明一下，场景所有资源来自虚幻商城。）</p>\n<h4 id=\"创建一个简单的第一人称射击例子\"><a href=\"#创建一个简单的第一人称射击例子\" class=\"headerlink\" title=\"创建一个简单的第一人称射击例子\"></a>创建一个简单的第一人称射击例子</h4><p>关卡就不说了，简单搭一下或使用默认的就行，这里先创建actor，在创建actor之前先搞个人物动画。<br>创建一个动画蓝图并选择白嫖的骨骼资源</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-14.png\">\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-15.png\">\n<p>这里动画蓝图比较简单，使用人物原地不动的一个动画，然后通过“变换（修改）骨骼”将上下的视角旋转信息给到腰部的骨骼以实现一个较为真实的第一人称视角感</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-16.png\">\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-17.png\">\n<p>现在创建actor，单击右键创建角色</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-18.png\">\n<p>选择角色模型（直接拖进来也阔以），并应用之前的动画蓝图，创建一个相机及一个箭头组件（用来发射子弹），这里的控制蓝图就不仔细展示了，都是第一人称通用的东西，太乱了，我自己都不想看了</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-19.png\">\n<p>将相机绑定到一个骨骼插槽（至于怎么创建….），适当调整相机坐标以获得一个较好的第一人称视角</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-20.png\">\n<p>至此，一个第一人称例子算是完成了，将actor拖到关卡中，看下效果还行</p>\n<img src=\"http://static.pa2sw0rd.cn/static/images/image-21.png\">\n<h4 id=\"使用C-创建socket服务端\"><a href=\"#使用C-创建socket服务端\" class=\"headerlink\" title=\"使用C++创建socket服务端\"></a>使用C++创建socket服务端</h4><p>创建一个C++类，父类继承actor组件（UActorComponent），但是只能作为actor的组件使用，这里说明一下，作为UE4的新手，起初查资料可以继承其它类，在蓝图实例化的时候总会false，无奈之下继承了actor组件。</p>\n<p>通过这几步实现一个socket服务器：初始化-绑定地址及端口-监听-数据接收，这里要明确一点，在我测试当中发现，actor是作为主线程运行的，其中监听及数据接收阶段会阻塞线程，会直接卡死，所以在这里我们需要创建线程去执行上述两步。但是作为线程的话我们需要共享一些对象及数据，因不知道UE4的全局变量，这里就用指针传递数据；</p>\n<p>创建一个初始化线程类（初始化也写到这里了）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MYDEMO_API acceptSocket :public FRunnable &#123; \npublic: \n    acceptSocket(FSocket* client, FSocket* server, FString ipAddr, INT32 port, float* x, float* y, float* z,bool* isAttack) : m_Client(client) ,m_Server(server),m_ipAddr(ipAddr),m_port(port),  m_x(x), m_y(y), m_z(z),m_isAttack(isAttack) \n    &#123;&#125; \n    ~acceptSocket() \n    &#123; \n        stopping &#x3D; true; \n    &#125; \n \n    virtual bool Init() override \n&#123; \n        stopping &#x3D; false; \n        return true; \n    &#125; \n \n    virtual uint32 Run() override \n&#123; \n \n        m_Server &#x3D; ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(&quot;default&quot;), false); \n \n        if (!m_Server) &#123; \n            GEngine-&gt;AddOnScreenDebugMessage \n            ( \n                -1, \n                10,                                  &#x2F;&#x2F;           显示的时间&#x2F;秒 \n                FColor::Blue,            &#x2F;&#x2F;           显示的颜色 \n                &quot;初始化server失败！&quot;           &#x2F;&#x2F;           显示的信息 \n            ); \n            return false; \n        &#125; \n        FIPv4Address ip; \n        FIPv4Address::Parse(m_ipAddr, ip); \n        TSharedRef&lt;FInternetAddr&gt; addr &#x3D; ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr(); \n        addr-&gt;SetIp(ip.Value); \n        addr-&gt;SetPort(m_port); \n        bool bBind &#x3D; m_Server-&gt;Bind(*addr); \n        if (!bBind) &#123; \n            return false; \n        &#125; \n        bool bListen &#x3D; m_Server-&gt;Listen(1); \n        if (!bListen) return false; \n        TSharedRef&lt;FInternetAddr&gt; targetAddr &#x3D; ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr(); \n        FIPv4Address::Parse(m_ipAddr, ip); \n        targetAddr-&gt;SetIp(ip.Value); \n        targetAddr-&gt;SetPort(m_port); \n        while (!stopping) \n        &#123; \n            m_Client &#x3D; m_Server-&gt;Accept(*targetAddr, &quot;aaa&quot;); \n            if (!m_Client) \n                continue; \n            INT32 temp; \n            FString data &#x3D; &quot;hello&quot;; \n            FRunnableThread::Create(new recvSocket(m_Client,m_x,m_y,m_z,m_isAttack),TEXT(&quot;RecvThread&quot;)); \n            if (m_Client-&gt;Send((uint8*)TCHAR_TO_ANSI(data.GetCharArray().GetData()), 5, temp)) &#123; \n                &#x2F;&#x2F;GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, TEXT(&quot;发送成功!&quot;)); \n            &#125; \n        &#125; \n         \n \n \n        return 1; \n    &#125; \n \n    virtual void Stop() override \n&#123; \n        stopping &#x3D; true;    &#x2F;&#x2F;计数器-1 \n    &#125; \n \nprivate: \n    FSocket* m_Client,*m_Server;  &#x2F;&#x2F;客户端套接字 \n    FString m_ipAddr; \n    INT32 m_port; \n    bool* m_isAttack; \n    float* m_x, * m_y, * m_z; \n    bool stopping;      &#x2F;&#x2F;循环控制 \n    FThreadSafeCounter m_StopTaskCounter;   &#x2F;&#x2F;线程引用计数器 \n&#125;;</code></pre>\n<p>数据接收线程，只是一个例子，就不校验数据准确性了，因为非硬件开发，就不考虑内存大小了，直接传字符串，发送前和接收后再转就行了。这里避免粘包，简单封装了一下数据帧，帧头帧尾为0x73(s)&#x2F;0x6f(o)，用逗号分割两个轴的旋转量，冒号分割是否开火状态。具体可以看代码。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass MYDEMO_API recvSocket :public FRunnable &#123; \npublic: \n    recvSocket(FSocket* client, float* x, float* y, float* z,bool* isAttack) : m_Client(client),m_x(x),m_y(y),m_z(z),m_isAttack(isAttack) \n    &#123;&#125; \n    ~recvSocket() \n    &#123; \n        stopping &#x3D; true; \n    &#125; \n \n    virtual bool Init() override \n&#123; \n        stopping &#x3D; false; \n        return true; \n    &#125; \n    FString StringFromBinaryArray(const TArray&lt;uint8&gt;&amp; BinaryArray) \n&#123; \n        return FString(ANSI_TO_TCHAR(reinterpret_cast&lt;const char*&gt;(BinaryArray.GetData()))); \n    &#125; \n \n    virtual uint32 Run() override \n&#123; \n        if (!m_Client) &#123; \n            return 1; \n        &#125; \n        TArray&lt;uint8&gt; recvBuffer; \n        uint32 size &#x3D; 1; \n        while (!stopping) \n        &#123; \n            try &#123; \n                if (m_Client-&gt;GetConnectionState() &#x3D;&#x3D; SCS_Connected) &#123; \n                    if (m_Client-&gt;HasPendingData(size)) &#123; \n                        recvBuffer.Init(0, 1024U); \n                        &#x2F;&#x2F;GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, TEXT(&quot;client is read to recv!!%d&quot;)); \n                        int32 element &#x3D; 0; \n                        m_Client-&gt;Recv(recvBuffer.GetData(), recvBuffer.Num(), element); \n                        &#x2F;&#x2F;GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, TEXT()); \n                         \n                        &#x2F;&#x2F;UE_LOG(LogTemp, Warning, TEXT(&quot;*** %c&quot;), recvBuffer.GetData()[0]); \n                         \n                        &#x2F;&#x2F;*m_x &#x3D; FCString::Atof(*StringFromBinaryArray(recvBuffer)); \n                        FString x &#x3D; &quot;&quot;; \n                        FString y &#x3D; &quot;&quot;; \n                        bool splitFlag &#x3D; false; \n                        bool frameFlag &#x3D; false; \n                        &#x2F;&#x2F;bool splitAttack &#x3D; false; \n                        &#x2F;* \n                        数据帧解析 \n                        *&#x2F; \n                        for (int i &#x3D; 0; i &lt; recvBuffer.Num(); i++) &#123; \n                            unsigned char temp &#x3D;recvBuffer.GetData()[i]; \n                            &#x2F;&#x2F;GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, FString::Printf(TEXT(&quot;%c\\n&quot;), temp)); \n                            if (temp &#x3D;&#x3D; &#39;o&#39;) &#123; \n                                frameFlag &#x3D; false; \n                                continue; \n                            &#125; \n \n                            if (frameFlag &amp;&amp; temp &#x3D;&#x3D; &#39;:&#39;) &#123; \n                                if (recvBuffer.GetData()[i+1] &#x3D;&#x3D; &#39;1&#39;) &#123; \n                                    *m_isAttack &#x3D; true; \n                                    continue; \n                                &#125; \n                                *m_isAttack &#x3D; false; \n                                continue; \n                            &#125; \n                            if (frameFlag &amp;&amp; temp &#x3D;&#x3D; &#39;,&#39;) &#123; \n                                splitFlag &#x3D; true; \n                                continue; \n                            &#125; \n                            if (frameFlag &amp;&amp; !splitFlag) &#123; \n                                x.AppendChar(recvBuffer.GetData()[i]); \n                                *m_x &#x3D; FCString::Atof(*x); \n                                continue; \n                                 \n                            &#125;if (frameFlag &amp;&amp; splitFlag) &#123; \n                                y.AppendChar(recvBuffer.GetData()[i]); \n                                *m_y &#x3D; FCString::Atof(*y); \n                                continue; \n                            &#125; \n                            if (temp &#x3D;&#x3D; &#39;s&#39;) &#123; \n                                frameFlag &#x3D; true; \n                                continue; \n                            &#125; \n                             \n                        &#125;    \n                        UE_LOG(LogTemp, Warning, TEXT(&quot;x: %s;&quot;), *x); \n                        UE_LOG(LogTemp, Warning, TEXT(&quot;y: %s;&quot;), *y); \n                        &#x2F;&#x2F;GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, TEXT(&quot;client is recved!!&quot;)); \n                    &#125;         \n                &#125; \n                else &#123; \n                    return 1; \n                &#125; \n                 \n            &#125; \n            catch (...) &#123; \n                UE_LOG(LogTemp, Warning, TEXT(&quot;有异常！&quot;)); \n                return 1; \n            &#125; \n        &#125; \n        return 1; \n    &#125; \n    virtual void Stop() override \n&#123; \n        stopping &#x3D; true;    &#x2F;&#x2F;计数器-1 \n    &#125; \nprivate: \n    FSocket* m_Client;  &#x2F;&#x2F;客户端套接字 \n    float* m_x, * m_y, * m_z; \n    bool* m_isAttack; \n    bool stopping;      &#x2F;&#x2F;循环控制 \n    FThreadSafeCounter m_StopTaskCounter;   &#x2F;&#x2F;线程引用计数器 \n&#125;</code></pre>\n<p>最后在我们的主类中定义相关方法及变量就OK了，这里用指针转递数据，指针可不能乱指，别忘了初始化指针</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UCLASS(ClassGroup &#x3D; &quot;Networking&quot;, meta &#x3D; (BlueprintSpawnableComponent)) \nclass MYDEMO_API UMySocketDemo : public UActorComponent \n&#123; \n           GENERATED_BODY() \n \npublic: \n           FSocket* server &#x3D; NULL; \n           FSocket* client&#x3D;NULL; \n    float *x&#x3D;NULL; \n    float *y &#x3D; NULL; \n    float *z &#x3D; NULL; \n    bool *isAttack &#x3D; NULL; \n           UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n                      bool init(const FString ipAddr, const int port); \n           UFUNCTION(BlueprintCallable,Category&#x3D;&quot;mySocket&quot;) \n                      bool initSocket(const FString ipAddr,const int port); \n \n           UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n                      bool closeSocket(); \n \n           UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n                      void myTest(); \n    UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n        float getXData(); \n    UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n        float getYData(); \n    UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n        bool getAttack(); \n            \n&#125;;\nbool UMySocketDemo::init(FString ipAddr, int port) &#123; \n    x &#x3D; (float*)malloc(sizeof(float)); \n    y &#x3D; (float*)malloc(sizeof(float)); \n    z &#x3D; (float*)malloc(sizeof(float)); \n    isAttack &#x3D; (bool*)malloc(sizeof(bool)); \n    GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, TEXT(&quot;accept run!&quot;)); \n    FRunnableThread::Create(new acceptSocket(client,server,ipAddr,port,x,y,z,isAttack),TEXT(&quot;监听线程！&quot;)); \n    return true; \n&#125;</code></pre>\n<h4 id=\"安卓端实现\"><a href=\"#安卓端实现\" class=\"headerlink\" title=\"安卓端实现\"></a>安卓端实现</h4><p>安卓无非就两个功能，采集陀螺仪数据，连接服务端并发送数据，要使用socket首先添加网络权限</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot;&#x2F;&gt;</code></pre>\n<p>创建一个socket类，用来连接及发送数据，连接地址及端口写死了，用的时候按需修改就行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.pa2sw0rd.myar; \n \nimport android.util.Log; \n \nimport java.io.BufferedWriter; \nimport java.io.IOException; \nimport java.io.OutputStream; \nimport java.io.OutputStreamWriter; \nimport java.net.Socket; \nimport java.net.SocketAddress; \nimport java.nio.charset.StandardCharsets; \n \npublic class MySocket &#123; \n    Socket socket&#x3D;null; \n    &#x2F;&#x2F;static SocketAddress socketAddress&#x3D;[&quot;127.0.0.1&quot;,998]; \n    public MySocket()&#123; \n        try &#123; \n            this.socket&#x3D;new Socket(&quot;192.168.1.104&quot;,998); \n        &#125; catch (IOException e) &#123; \n            e.printStackTrace(); \n        &#125; \n    &#125; \n    public void send(String data) &#123; \n        try&#123; \n            BufferedWriter bufferedWriter&#x3D;null; \n            try &#123; \n                bufferedWriter &#x3D; new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); \n            &#125; catch (IOException e) &#123; \n                Log.d(&quot;Client&quot;,&quot;BufferedWriter出错&quot;); \n                e.printStackTrace(); \n            &#125; \n            try &#123; \n                &#x2F;&#x2F; 发送数据 \n                bufferedWriter.write(data); \n                bufferedWriter.flush(); \n                &#x2F;&#x2F;bufferedWriter.close(); \n            &#125; catch (IOException e) &#123; \n                Log.d(&quot;Client&quot;,&quot;发送数据出错&quot;); \n                e.printStackTrace(); \n            &#125; \n        &#125;catch (Exception e)&#123; \n            &#x2F;&#x2F;e.printStackTrace(); \n        &#125; \n \n    &#125; \n&#125;</code></pre>\n<p>在oncreate中初始化相关view、传感器及socket</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> private void init()&#123; \n    this.textView&#x3D;findViewById(R.id.TextView); \n    this.sensorManager&#x3D;(SensorManager) getSystemService(Context.SENSOR_SERVICE); \n    this.mySocket&#x3D;new MySocket(); \n&#125;</code></pre>\n<p>重写两个方法，在退出APP和回到APP时重写卸载&#x2F;注册传感器,这里使用快速采样SENSOR_DELAY_FASTEST，效果好一点</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override \nprotected void onPause() &#123; \n    super.onPause(); \n    if(this.sensorManager!&#x3D;null)&#123; \n        this.sensorManager.unregisterListener(this); \n    &#125; \n\n&#125; \n@Override \nprotected void onResume() &#123; \n    super.onResume(); \n    this.sensorManager.registerListener(this, \n            sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE), \n            SensorManager.SENSOR_DELAY_FASTEST); \n\n&#125;</code></pre>\n<p>最获取陀螺仪数据，简单封装一下发送到服务端，至此，我们的一个陀螺仪ar例子就完成了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\n@Override \npublic void onSensorChanged(SensorEvent event) &#123; \n    if (event.sensor.getType() &#x3D;&#x3D; Sensor.TYPE_GYROSCOPE) &#123; &#x2F;&#x2F; 陀螺仪角度变更事件 \n        if (mTimestamp !&#x3D; 0) &#123; \n            final float dT &#x3D; (event.timestamp - mTimestamp) * NS2S; \n            mAngle[0] +&#x3D; event.values[0] * dT; \n            mAngle[1] +&#x3D; event.values[1] * dT; \n            mAngle[2] +&#x3D; event.values[2] * dT; \n            float angleX &#x3D; (float) Math.toDegrees(mAngle[0]); \n            float angleY &#x3D; (float) Math.toDegrees(mAngle[1]); \n            float angleZ &#x3D; (float) Math.toDegrees(mAngle[2]); \n            String z&#x3D;String.format(&quot;%f&quot;,angleZ); \n            String sendData&#x3D;&quot;s&quot;+z+&quot;,&quot;+String.format(&quot;%f&quot;,angleX)+&quot;:&quot;+(this.isParsed?&quot;1&quot;:&quot;0&quot;)+&quot;o&quot;; \n            &#x2F;&#x2F;this.sensorManager.getOrientation(r,values); \n            &#x2F;&#x2F;String desc &#x3D; String.format(&quot;陀螺仪检测到当前\\nx轴方向的转动角度为%f\\ny轴方向的转动角度为%f\\nz轴方向的转动角度为%f&quot;, r[0], values[1], values[2]); \n            this.mySocket.send(sendData); \n            this.textView.setText(sendData); \n        &#125; \n        mTimestamp &#x3D; event.timestamp; \n    &#125; \n&#125;</code></pre>\n<h3 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h3><p>因为没有对陀螺仪的数据进行滤波，画面看起来有点抖动</p>\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=894666027&bvid=BV1MP4y137km&cid=548011461&page=1\"  scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"></iframe>\n</div>","text":"前言在我们的印象里，如果想体验AR游戏，那么就得有一定的硬件支持，其实简单来说，一个AR游戏就是利用电脑模拟产生一个三维空间的虚拟世界，通过相应的硬件传感器将人...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"开发","slug":"开发","count":4,"path":"api/categories/开发.json"},{"name":"ue4","slug":"开发/ue4","count":1,"path":"api/categories/开发/ue4.json"},{"name":"ue4","slug":"ue4","count":1,"path":"api/categories/ue4.json"},{"name":"c++","slug":"ue4/c","count":1,"path":"api/categories/ue4/c.json"}],"tags":[{"name":"虚幻4引擎","slug":"虚幻4引擎","count":1,"path":"api/tags/虚幻4引擎.json"},{"name":"陀螺仪","slug":"陀螺仪","count":1,"path":"api/tags/陀螺仪.json"},{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"},{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9F%A5%E8%AF%86%E7%82%B9\"><span class=\"toc-text\">知识点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90\"><span class=\"toc-text\">系统分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">实现步骤</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0%E5%B0%84%E5%87%BB%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">创建一个简单的第一人称射击例子</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8C-%E5%88%9B%E5%BB%BAsocket%E6%9C%8D%E5%8A%A1%E7%AB%AF\"><span class=\"toc-text\">使用C++创建socket服务端</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%8D%93%E7%AB%AF%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">安卓端实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C\"><span class=\"toc-text\">最终效果</span></a></li></ol>","author":{"name":"Pa2sw0rd","slug":"blog-author","avatar":"http://static.pa2sw0rd.cn/static/images/pa2sw0rd.webp","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：Pa2sw0rd</b>","socials":{"github":"https://github.com/Pa2sw0rd","twitter":"https://twitter.com/pa2sword","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"douyin":{"icon":"/svg/douyin.svg","link":"https://www.douyin.com/user/MS4wLjABAAAA-Ohh-uecs-fV_2dHQpkNPD8KUHel_Mzuok9jyxBAJmM"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"路上的优盘不要捡！硬核打造BadUSB近源渗透神器，一秒上线MSF！","uid":"68207a8407ad9919ae03a48d7f395abc","slug":"bad_usb","date":"2022-05-24T07:59:24.000Z","updated":"2023-08-27T15:50:26.974Z","comments":true,"path":"api/articles/bad_usb.json","keywords":null,"cover":"https://images.unsplash.com/photo-1544731612-de7f96afe55f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxfDB8MXxyYW5kb218MHx8Y3VtcHV0ZXIsaGFyZHdhcmV8fHx8fHwxNjkyNzA3MTIz&ixlib=rb-4.0.3&q=80&utm_campaign=api-credit&utm_medium=referral&utm_source=unsplash_source&w=1080","text":"简介&emsp; &emsp; 近期拿出吃灰的stm32f407开发板，研究学习一下hid设备的开发，来实现一个低成本的badusb，本文使用开发板来进行测试，...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"安全","slug":"安全","count":7,"path":"api/categories/安全.json"},{"name":"硬件","slug":"安全/硬件","count":1,"path":"api/categories/安全/硬件.json"}],"tags":[{"name":"硬件","slug":"硬件","count":1,"path":"api/tags/硬件.json"},{"name":"BadUSB","slug":"BadUSB","count":1,"path":"api/tags/BadUSB.json"}],"author":{"name":"Pa2sw0rd","slug":"blog-author","avatar":"http://static.pa2sw0rd.cn/static/images/pa2sw0rd.webp","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：Pa2sw0rd</b>","socials":{"github":"https://github.com/Pa2sw0rd","twitter":"https://twitter.com/pa2sword","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"douyin":{"icon":"/svg/douyin.svg","link":"https://www.douyin.com/user/MS4wLjABAAAA-Ohh-uecs-fV_2dHQpkNPD8KUHel_Mzuok9jyxBAJmM"}}}},"feature":true},"next_post":{"title":"ARM Contex-A8裸机DS18B20驱动","uid":"541b240588262648fd83a34d7c89d5e4","slug":"ARM-Contex-A8-ds18b20","date":"2021-07-03T06:52:19.000Z","updated":"2023-08-27T15:45:05.641Z","comments":true,"path":"api/articles/ARM-Contex-A8-ds18b20.json","keywords":null,"cover":"https://images.unsplash.com/photo-1505424297051-c3ad50b055ae?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxfDB8MXxyYW5kb218MHx8cGNifHx8fHx8MTY5MzE1MDgyOA&ixlib=rb-4.0.3&q=80&utm_campaign=api-credit&utm_medium=referral&utm_source=unsplash_source&w=1080","text":"近期做一个裸机采集温度的设计，要求裸机实现，网上DS18B20的驱动资料很多，但是基本都是51和STM32以及通过跑操作系统驱动实现的，这方面的资料少之又少。经...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"开发","slug":"开发","count":4,"path":"api/categories/开发.json"},{"name":"硬件","slug":"开发/硬件","count":2,"path":"api/categories/开发/硬件.json"},{"name":"硬件","slug":"硬件","count":2,"path":"api/categories/硬件.json"},{"name":"裸机","slug":"硬件/裸机","count":1,"path":"api/categories/硬件/裸机.json"}],"tags":[{"name":"开发","slug":"开发","count":2,"path":"api/tags/开发.json"},{"name":"嵌入式","slug":"嵌入式","count":1,"path":"api/tags/嵌入式.json"},{"name":"三星s5pv210","slug":"三星s5pv210","count":1,"path":"api/tags/三星s5pv210.json"}],"author":{"name":"Pa2sw0rd","slug":"blog-author","avatar":"http://static.pa2sw0rd.cn/static/images/pa2sw0rd.webp","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：Pa2sw0rd</b>","socials":{"github":"https://github.com/Pa2sw0rd","twitter":"https://twitter.com/pa2sword","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"douyin":{"icon":"/svg/douyin.svg","link":"https://www.douyin.com/user/MS4wLjABAAAA-Ohh-uecs-fV_2dHQpkNPD8KUHel_Mzuok9jyxBAJmM"}}}}}}